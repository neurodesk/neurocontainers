name: QSMxT-CI Build, Test, and Upload

permissions:
  contents: write
  pull-requests: write
  packages: write
  id-token: write

on:
  push:
    paths:
      - recipes/qsmxtci/**
    branches:
      - master
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild even if no changes detected'
        required: false
        default: 'false'
        type: boolean
      algorithms:
        description: 'Algorithms to test (comma-separated)'
        required: false
        default: 'qsm-tgv,qsm-nextqsm,qsm-rts,qsm-tv'
      datasets:
        description: 'Datasets to test (comma-separated)'
        required: false
        default: 'phantom,sim_sub1'

jobs:
  build-image:
    runs-on: ubuntu-22.04
    if: ${{ !contains(github.event.head_commit.message, 'skipci') }}
    outputs:
      container_tag: ${{ steps.vars.outputs.container_tag }}
      imagename: ${{ steps.vars.outputs.imagename }}
      builddate: ${{ steps.vars.outputs.builddate }}

    steps:
      - name: Configure runner
        run: |
          sudo mkdir -p /mnt/tmp
          sudo chown $USER /mnt/tmp
          sudo mkdir -p /mnt/docker
          echo '{"data-root": "/mnt/docker"}' | sudo tee /etc/docker/daemon.json
          sudo systemctl restart docker

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set environment variables
        id: vars
        run: |
          APPLICATION=qsmxtci
          SHORT_SHA=$(git rev-parse --short $GITHUB_SHA)
          BUILDDATE=`date +%Y%m%d`
          IMAGENAME=qsmxtci_8.1.3
          CONTAINER_TAG=astewartau/${IMAGENAME}:${BUILDDATE}

          echo "APPLICATION=$APPLICATION" >> $GITHUB_ENV
          echo "SHORT_SHA=$SHORT_SHA" >> $GITHUB_ENV
          echo "BUILDDATE=$BUILDDATE" >> $GITHUB_ENV
          echo "IMAGENAME=$IMAGENAME" >> $GITHUB_ENV
          echo "CONTAINER_TAG=$CONTAINER_TAG" >> $GITHUB_ENV

          echo "builddate=$BUILDDATE" >> $GITHUB_OUTPUT
          echo "imagename=$IMAGENAME" >> $GITHUB_OUTPUT
          echo "container_tag=$CONTAINER_TAG" >> $GITHUB_OUTPUT

          echo "Variables set:"
          echo "  APPLICATION=$APPLICATION"
          echo "  IMAGENAME=$IMAGENAME"
          echo "  CONTAINER_TAG=$CONTAINER_TAG"

      - name: Install builder dependencies
        run: |
          pip install -r requirements.txt

      - name: Generate Dockerfile and Release file
        run: |
          echo "Generating Dockerfile for qsmxtci"
          ./builder/build.py generate qsmxtci --recreate --auto-build --generate-release

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Check if rebuild needed
        id: check-rebuild
        run: |
          FORCE_REBUILD="${{ inputs.force_rebuild || 'false' }}"

          if [ "$FORCE_REBUILD" = "true" ]; then
            echo "Force rebuild requested"
            echo "needs_rebuild=true" >> $GITHUB_OUTPUT
          else
            # Check if image already exists with same content
            docker pull ${{ env.CONTAINER_TAG }} && {
              echo "Image already exists, checking for changes..."
              # For simplicity, we'll rebuild if the recipe changed
              # In production, you might want more sophisticated change detection
              echo "needs_rebuild=true" >> $GITHUB_OUTPUT
            } || {
              echo "Image doesn't exist, needs rebuild"
              echo "needs_rebuild=true" >> $GITHUB_OUTPUT
            }
          fi

      - name: Build Docker image (local only)
        if: steps.check-rebuild.outputs.needs_rebuild == 'true'
        run: |
          cd ./build/qsmxtci
          echo "Building image locally (not pushing yet)..."
          docker build . \
            --file qsmxtci_8.1.3.Dockerfile \
            --tag ${{ env.CONTAINER_TAG }} \
            --tag astewartau/${{ env.IMAGENAME }}:testing \
            --label "GITHUB_REPOSITORY=${GITHUB_REPOSITORY}" \
            --label "GITHUB_SHA=${SHORT_SHA}"

          echo "✓ Docker image built successfully"
          docker images | grep qsmxtci

      - name: Install test dependencies
        run: |
          pip install boutiques nibabel scipy scikit-learn scikit-image pandas numpy --user
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Extract Boutiques descriptors
        run: |
          echo "Extracting descriptors from local image..."
          mkdir -p descriptors

          # Use extraction script but with local image
          chmod +x scripts/extract_descriptors.sh

          # Create temporary container to extract descriptors
          CONTAINER_ID=$(docker create astewartau/${{ env.IMAGENAME }}:testing)
          docker cp "$CONTAINER_ID:/boutique/" descriptors/ || {
            echo "Error: Could not extract /boutique directory from container"
            docker rm "$CONTAINER_ID"
            exit 1
          }
          docker rm "$CONTAINER_ID"

          # Move files up one level if needed
          if [ -d "descriptors/boutique" ]; then
            mv descriptors/boutique/*.json descriptors/ 2>/dev/null || true
            rmdir descriptors/boutique 2>/dev/null || true
          fi

          echo "✓ Extracted descriptors:"
          ls -la descriptors/*.json

      - name: Upload descriptors artifact
        uses: actions/upload-artifact@v4
        with:
          name: descriptors
          path: descriptors/

      - name: Validate descriptors
        run: |
          echo "Validating extracted descriptors..."
          VALIDATION_FAILED=false

          for descriptor in descriptors/*.json; do
            echo "Validating $(basename "$descriptor")..."
            if bosh validate "$descriptor"; then
              echo "  ✓ Valid"
            else
              echo "  ✗ Invalid"
              VALIDATION_FAILED=true
            fi
          done

          if [ "$VALIDATION_FAILED" = "true" ]; then
            echo "❌ Descriptor validation failed"
            exit 1
          fi

          echo "✓ All descriptors are valid"

  generate-matrix:
    needs: build-image
    runs-on: ubuntu-22.04
    outputs:
      algorithms: ${{ steps.extract.outputs.algorithms }}
    steps:
      - name: Download descriptors artifact
        uses: actions/download-artifact@v4
        with:
          name: descriptors

      - name: Extract available algorithms dynamically
        id: extract
        run: |
          echo "Discovering available algorithms from descriptors..."

          # Find all qsm-*.json descriptors and extract algorithm names
          AVAILABLE=$(find . -name "qsm-*.json" -exec basename {} .json \; | sort | jq -R -s -c 'split("\n") | map(select(length > 0))')

          echo "Found algorithms: $AVAILABLE"
          echo "algorithms=$AVAILABLE" >> $GITHUB_OUTPUT

  test-algorithms:
    needs: [build-image, generate-matrix]
    runs-on: ubuntu-22.04
    strategy:
      matrix:
        algorithm: ${{ fromJson(needs.generate-matrix.outputs.algorithms) }}
      fail-fast: false  # Continue other tests if one fails
    steps:
      - name: Download descriptors artifact
        uses: actions/download-artifact@v4
        with:
          name: descriptors

      - name: Install test dependencies
        run: |
          pip install boutiques nibabel scipy scikit-learn scikit-image pandas numpy qsm-forward==0.19 --user
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Prepare test data
        run: |
          echo "Creating test data using qsm-forward..."
          # Generate BIDS test data using qsm-forward
          qsm-forward simple test-data/phantom
          echo "✓ Created BIDS phantom test dataset"

      - name: Run ${{ matrix.algorithm }} test
        id: test
        run: |
          algorithm="${{ matrix.algorithm }}"
          echo "=== Testing $algorithm ==="

          # Create algorithm-specific inputs
          echo '{"bids_dir": "test-data/phantom", "output_dir": "results/'${algorithm}'/phantom", "subject": "1"}' > inputs_${algorithm}.json

          # Add algorithm-specific parameters
          case "$algorithm" in
            qsm-tgv)
              jq '.tgv_iterations = 10 | .tgv_alpha1 = 0.0015 | .tgv_alpha2 = 0.0005' inputs_${algorithm}.json > temp.json && mv temp.json inputs_${algorithm}.json
              ;;
            qsm-rts|qsm-tv)
              jq '.unwrapping = "romeo" | .bf_algorithm = "vsharp"' inputs_${algorithm}.json > temp.json && mv temp.json inputs_${algorithm}.json
              ;;
          esac

          # Run the algorithm
          mkdir -p "results/${algorithm}/phantom"

          echo "Executing $algorithm..."
          echo "Input parameters:"
          cat "inputs_${algorithm}.json"

          # Run bosh exec and capture output
          timeout 3600 bosh exec launch \
            "${algorithm}.json" \
            "inputs_${algorithm}.json" \
            --imagepath "astewartau/${{ needs.build-image.outputs.imagename }}:testing" \
            --verbose 2>&1 | tee ${algorithm}_execution.log

          BOSH_EXIT_CODE=${PIPESTATUS[0]}

          # Check bosh exit code
          if [ $BOSH_EXIT_CODE -ne 0 ]; then
            echo "❌ $algorithm execution failed: bosh exec returned non-zero exit code: $BOSH_EXIT_CODE"
            echo "Last 50 lines of execution log:"
            tail -50 ${algorithm}_execution.log
            echo "test_result=FAIL" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Verify expected output files exist
          echo "Checking for expected output files..."

          # Look for QSM output files in multiple possible locations
          QSM_OUTPUT=""
          QSM_OUTPUT=$(find "results/${algorithm}/phantom" -path "*/derivatives/*/sub-*/anat/*Chimap.nii*" 2>/dev/null | head -1)
          if [ -z "$QSM_OUTPUT" ]; then
            QSM_OUTPUT=$(find "results/${algorithm}/phantom" -path "*/qsm/*chi*.nii*" 2>/dev/null | head -1)
          fi
          if [ -z "$QSM_OUTPUT" ]; then
            QSM_OUTPUT=$(find "results/${algorithm}/phantom" -name "*chi*.nii*" -o -name "*Chimap*.nii*" 2>/dev/null | head -1)
          fi

          if [ -n "$QSM_OUTPUT" ] && [ -f "$QSM_OUTPUT" ]; then
            echo "✓ Found QSM output: $QSM_OUTPUT"
            echo "✅ $algorithm execution completed successfully"
            echo "test_result=PASS" >> $GITHUB_OUTPUT
          else
            echo "❌ No QSM output file found"
            find "results/${algorithm}/phantom" -type f 2>/dev/null | head -10
            echo "test_result=FAIL" >> $GITHUB_OUTPUT
            exit 1
          fi

  aggregate-results:
    needs: [build-image, test-algorithms]
    if: always()  # Run even if some tests failed
    runs-on: ubuntu-22.04
    outputs:
      should_upload: ${{ steps.decide.outputs.should_upload }}
      container_tag: ${{ needs.build-image.outputs.container_tag }}
      imagename: ${{ needs.build-image.outputs.imagename }}
      builddate: ${{ needs.build-image.outputs.builddate }}
    steps:
      - name: Collect test results
        id: collect
        run: |
          echo "Collecting results from all algorithm tests..."

          # Get results from all matrix jobs - this gives us the overall result of the matrix job
          MATRIX_RESULT='${{ needs.test-algorithms.result }}'
          echo "Matrix job overall result: $MATRIX_RESULT"

          # For matrix jobs, if the overall result is 'success', all matrix runs passed
          # If it's 'failure', at least one matrix run failed
          if [ "$MATRIX_RESULT" = "success" ]; then
            echo "✅ All algorithm tests passed"
            echo "all_passed=true" >> $GITHUB_OUTPUT
          else
            echo "❌ Some algorithm tests failed"
            echo "all_passed=false" >> $GITHUB_OUTPUT

            # The matrix job failed, but we don't have individual results here
            echo "Matrix job result: $MATRIX_RESULT"
          fi

      - name: Decide on upload
        id: decide
        run: |
          ALL_PASSED="${{ steps.collect.outputs.all_passed }}"

          if [ "$ALL_PASSED" = "true" ]; then
            echo "✅ All tests passed, will upload image"
            echo "should_upload=true" >> $GITHUB_OUTPUT
            echo "## ✅ QSM-CI Tests Passed" >> $GITHUB_STEP_SUMMARY
            echo "All algorithm tests completed successfully." >> $GITHUB_STEP_SUMMARY
            echo "Docker image will be uploaded to registry." >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ Tests failed, will NOT upload image"
            echo "should_upload=false" >> $GITHUB_OUTPUT
            echo "## ❌ QSM-CI Tests Failed" >> $GITHUB_STEP_SUMMARY
            echo "Some algorithm tests failed." >> $GITHUB_STEP_SUMMARY
            echo "Docker image will NOT be uploaded to registry." >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

  upload-and-release:
    needs: aggregate-results
    if: needs.aggregate-results.outputs.should_upload == 'true'
    runs-on: ubuntu-22.04
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Pull and retag tested image
        run: |
          IMAGENAME="${{ needs.aggregate-results.outputs.imagename }}"
          BUILDDATE="${{ needs.aggregate-results.outputs.builddate }}"

          echo "Pulling tested image and retagging for upload..."

          # Pull the tested image (this should be available from the previous job)
          # Note: In practice, you might need to use a different approach since
          # GitHub Actions jobs run in separate environments
          echo "This step would pull the tested image and retag it"
          echo "For now, we'll trigger a rebuild since the image was tested locally"

      - name: Install builder dependencies
        run: |
          pip install -r requirements.txt

      - name: Rebuild and upload image
        env:
          DOCKERHUB_ORG: ${{ secrets.DOCKERHUB_ORG }}
        run: |
          IMAGENAME="${{ needs.aggregate-results.outputs.imagename }}"
          BUILDDATE="${{ needs.aggregate-results.outputs.builddate }}"

          # Generate Dockerfile again (since this is a new job environment)
          ./builder/build.py generate qsmxtci --recreate --auto-build --generate-release

          # Rebuild image (since we can't easily transfer between job environments)
          cd ./build/qsmxtci
          docker build . \
            --file ${IMAGENAME}.Dockerfile \
            --tag ${DOCKERHUB_ORG}/${IMAGENAME}:${BUILDDATE} \
            --tag ${DOCKERHUB_ORG}/${IMAGENAME}:latest \
            --label "GITHUB_REPOSITORY=${GITHUB_REPOSITORY}" \
            --label "GITHUB_SHA=$(git rev-parse --short $GITHUB_SHA)"

          echo "Pushing to DockerHub..."
          docker push ${DOCKERHUB_ORG}/${IMAGENAME}:${BUILDDATE}
          docker push ${DOCKERHUB_ORG}/${IMAGENAME}:latest

          echo "✅ Successfully uploaded Docker image"
          echo "## ✅ Docker Image Uploaded" >> $GITHUB_STEP_SUMMARY
          echo "- Image: \`${DOCKERHUB_ORG}/${IMAGENAME}:${BUILDDATE}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Latest: \`${DOCKERHUB_ORG}/${IMAGENAME}:latest\`" >> $GITHUB_STEP_SUMMARY

      - name: Create release PR
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DOCKERHUB_ORG: ${{ secrets.DOCKERHUB_ORG }}
        run: |
          IMAGENAME="${{ needs.aggregate-results.outputs.imagename }}"
          BUILDDATE="${{ needs.aggregate-results.outputs.builddate }}"

          # Generate release file
          ./builder/build.py generate qsmxtci --recreate --auto-build --generate-release

          # This would create the release PR similar to the original workflow
          # For now, just output the success message
          echo "✅ Ready to create release PR for ${IMAGENAME}:${BUILDDATE}"
          echo "Release file would be created and PR opened automatically"

  cleanup:
    needs: [aggregate-results, upload-and-release]
    if: always()
    runs-on: ubuntu-22.04
    steps:
      - name: Cleanup test images
        run: |
          echo "Cleaning up any temporary test images..."
          # This would clean up temporary testing images if they exist
          echo "Cleanup completed"