name: QSM Algorithm CI - Build, Test, and Upload

permissions:
  contents: write
  pull-requests: write
  packages: write
  id-token: write

on:
  push:
    paths:
      - recipes/**/build.yaml  # Trigger on any recipe changes
    branches:
      - master
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild even if no changes detected'
        required: false
        default: 'false'
        type: boolean
      algorithms:
        description: 'Algorithms to test (comma-separated)'
        required: false
        default: 'qsm-tgv,qsm-nextqsm,qsm-rts,qsm-tv'
      datasets:
        description: 'Datasets to test (comma-separated)'
        required: false
        default: 'phantom,sim_sub1'

jobs:
  build-image:
    runs-on: ubuntu-22.04
    if: ${{ !contains(github.event.head_commit.message, 'skipci') }}
    outputs:
      container_tag: ${{ steps.vars.outputs.container_tag }}
      imagename: ${{ steps.vars.outputs.imagename }}
      builddate: ${{ steps.vars.outputs.builddate }}

    steps:
      - name: Configure runner
        run: |
          sudo mkdir -p /mnt/tmp
          sudo chown $USER /mnt/tmp
          sudo mkdir -p /mnt/docker
          echo '{"data-root": "/mnt/docker"}' | sudo tee /etc/docker/daemon.json
          sudo systemctl restart docker

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed recipe
        id: detect-recipe
        run: |
          # Detect which recipe was changed
          CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
          echo "Changed files: $CHANGED_FILES"

          # Find recipe directory from changed build.yaml files
          RECIPE_DIR=""
          for file in $CHANGED_FILES; do
            if [[ "$file" == recipes/*/build.yaml ]]; then
              RECIPE_DIR=$(dirname "$file")
              break
            fi
          done

          if [ -z "$RECIPE_DIR" ]; then
            echo "No recipe build.yaml changes detected, using qsmxtci as default"
            RECIPE_DIR="recipes/qsmxtci"
          fi

          RECIPE_NAME=$(basename "$RECIPE_DIR")
          echo "Detected recipe: $RECIPE_NAME"
          echo "recipe_name=$RECIPE_NAME" >> $GITHUB_OUTPUT
          echo "recipe_dir=$RECIPE_DIR" >> $GITHUB_OUTPUT

      - name: Set environment variables
        id: vars
        run: |
          RECIPE_NAME="${{ steps.detect-recipe.outputs.recipe_name }}"
          APPLICATION="$RECIPE_NAME"
          SHORT_SHA=$(git rev-parse --short $GITHUB_SHA)
          BUILDDATE=`date +%Y%m%d`

          # Get version from build.yaml
          VERSION=$(yq eval '.version' ${{ steps.detect-recipe.outputs.recipe_dir }}/build.yaml)
          IMAGENAME="${RECIPE_NAME}_${VERSION}"
          CONTAINER_TAG=astewartau/${IMAGENAME}:${BUILDDATE}

          echo "APPLICATION=$APPLICATION" >> $GITHUB_ENV
          echo "SHORT_SHA=$SHORT_SHA" >> $GITHUB_ENV
          echo "BUILDDATE=$BUILDDATE" >> $GITHUB_ENV
          echo "IMAGENAME=$IMAGENAME" >> $GITHUB_ENV
          echo "CONTAINER_TAG=$CONTAINER_TAG" >> $GITHUB_ENV

          echo "builddate=$BUILDDATE" >> $GITHUB_OUTPUT
          echo "imagename=$IMAGENAME" >> $GITHUB_OUTPUT
          echo "container_tag=$CONTAINER_TAG" >> $GITHUB_OUTPUT

          echo "Variables set:"
          echo "  APPLICATION=$APPLICATION"
          echo "  IMAGENAME=$IMAGENAME"
          echo "  CONTAINER_TAG=$CONTAINER_TAG"

      - name: Install builder dependencies
        run: |
          pip install -r requirements.txt

      - name: Generate Dockerfile and Release file
        run: |
          RECIPE_NAME="${{ steps.detect-recipe.outputs.recipe_name }}"
          echo "Generating Dockerfile for $RECIPE_NAME"
          ./builder/build.py generate "$RECIPE_NAME" --recreate --auto-build --generate-release

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Check if rebuild needed
        id: check-rebuild
        run: |
          FORCE_REBUILD="${{ inputs.force_rebuild || 'false' }}"

          if [ "$FORCE_REBUILD" = "true" ]; then
            echo "Force rebuild requested"
            echo "needs_rebuild=true" >> $GITHUB_OUTPUT
          else
            # Check if image already exists with same content
            docker pull ${{ env.CONTAINER_TAG }} && {
              echo "Image already exists, checking for changes..."
              # For simplicity, we'll rebuild if the recipe changed
              # In production, you might want more sophisticated change detection
              echo "needs_rebuild=true" >> $GITHUB_OUTPUT
            } || {
              echo "Image doesn't exist, needs rebuild"
              echo "needs_rebuild=true" >> $GITHUB_OUTPUT
            }
          fi

      - name: Build Docker image (local only)
        if: steps.check-rebuild.outputs.needs_rebuild == 'true'
        run: |
          RECIPE_NAME="${{ steps.detect-recipe.outputs.recipe_name }}"
          cd "./build/$RECIPE_NAME"
          echo "Building image locally (not pushing yet)..."
          docker build . \
            --file ${{ env.IMAGENAME }}.Dockerfile \
            --tag ${{ env.CONTAINER_TAG }} \
            --tag astewartau/${{ env.IMAGENAME }}:testing \
            --label "GITHUB_REPOSITORY=${GITHUB_REPOSITORY}" \
            --label "GITHUB_SHA=${SHORT_SHA}"

          echo "✓ Docker image built successfully"
          docker images | grep "$RECIPE_NAME"

      - name: Install test dependencies
        run: |
          pip install boutiques nibabel scipy scikit-learn scikit-image pandas numpy --user
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Extract Boutiques descriptors
        run: |
          echo "Extracting descriptors from local image..."
          mkdir -p descriptors

          # Use extraction script but with local image
          chmod +x scripts/extract_descriptors.sh

          # Create temporary container to extract descriptors
          CONTAINER_ID=$(docker create astewartau/${{ env.IMAGENAME }}:testing)
          docker cp "$CONTAINER_ID:/boutique/" descriptors/ || {
            echo "Error: Could not extract /boutique directory from container"
            docker rm "$CONTAINER_ID"
            exit 1
          }
          docker rm "$CONTAINER_ID"

          # Move files up one level if needed
          if [ -d "descriptors/boutique" ]; then
            mv descriptors/boutique/*.json descriptors/ 2>/dev/null || true
            rmdir descriptors/boutique 2>/dev/null || true
          fi

          echo "✓ Extracted descriptors:"
          ls -la descriptors/*.json

      - name: Upload descriptors artifact
        uses: actions/upload-artifact@v4
        with:
          name: descriptors
          path: descriptors/

      - name: Validate descriptors
        run: |
          echo "Validating extracted descriptors..."
          VALIDATION_FAILED=false

          for descriptor in descriptors/*.json; do
            echo "Validating $(basename "$descriptor")..."
            if bosh validate "$descriptor"; then
              echo "  ✓ Valid"
            else
              echo "  ✗ Invalid"
              VALIDATION_FAILED=true
            fi
          done

          if [ "$VALIDATION_FAILED" = "true" ]; then
            echo "❌ Descriptor validation failed"
            exit 1
          fi

          echo "✓ All descriptors are valid"

  generate-qsm-matrix:
    needs: build-image
    runs-on: ubuntu-22.04
    outputs:
      qsm_algorithms: ${{ steps.extract-qsm.outputs.qsm_algorithms }}
    steps:
      - name: Download descriptors artifact
        uses: actions/download-artifact@v4
        with:
          name: descriptors

      - name: Extract QSM algorithms using tags
        id: extract-qsm
        run: |
          echo "Discovering QSM algorithms from descriptor tags..."

          # Find all descriptors tagged for QSM evaluation
          QSM_ALGOS=()
          for descriptor in *.json; do
            if [ -f "$descriptor" ]; then
              # Check if this descriptor is tagged for QSM evaluation
              EVALUATION=$(jq -r '.tags.evaluation // empty' "$descriptor" 2>/dev/null)
              CATEGORY=$(jq -r '.tags.category // empty' "$descriptor" 2>/dev/null)
              DOMAIN=$(jq -r '.tags.domain // empty' "$descriptor" 2>/dev/null)

              if [[ "$EVALUATION" == "qsm-ci" ]] || [[ "$CATEGORY" == "qsm-reconstruction" ]] || [[ "$DOMAIN" == "quantitative-susceptibility-mapping" ]]; then
                ALGO_NAME=$(jq -r '.name' "$descriptor")
                QSM_ALGOS+=("$ALGO_NAME")
                echo "✓ Found QSM algorithm: $ALGO_NAME"
              fi
            fi
          done

          # Convert to JSON array
          QSM_ALGOS_JSON=$(printf '%s\n' "${QSM_ALGOS[@]}" | jq -R -s -c 'split("\n") | map(select(length > 0))')

          echo "QSM algorithms discovered: $QSM_ALGOS_JSON"
          echo "qsm_algorithms=$QSM_ALGOS_JSON" >> $GITHUB_OUTPUT

          if [ ${#QSM_ALGOS[@]} -eq 0 ]; then
            echo "⚠️  No QSM algorithms found in descriptors"
            exit 1
          fi

  test-qsm-algorithms:
    needs: [build-image, generate-qsm-matrix]
    runs-on: ubuntu-22.04
    strategy:
      matrix:
        algorithm: ${{ fromJson(needs.generate-qsm-matrix.outputs.qsm_algorithms) }}
      fail-fast: false  # Continue other tests if one fails
    steps:
      - name: Download descriptors artifact
        uses: actions/download-artifact@v4
        with:
          name: descriptors

      - name: Install test dependencies
        run: |
          pip install boutiques nibabel scipy scikit-learn scikit-image pandas numpy qsm-forward==0.19 --user
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Prepare test data
        run: |
          echo "Creating test data using qsm-forward..."
          # Generate BIDS test data using qsm-forward
          qsm-forward simple test-data/phantom
          echo "✓ Created BIDS phantom test dataset"

      - name: Run ${{ matrix.algorithm }} test
        id: test
        run: |
          algorithm="${{ matrix.algorithm }}"
          echo "=== Testing $algorithm ==="

          # Create algorithm-specific inputs
          echo '{"bids_dir": "test-data/phantom", "output_dir": "results/'${algorithm}'/phantom", "subject": "1"}' > inputs_${algorithm}.json

          # Add algorithm-specific parameters
          case "$algorithm" in
            qsm-tgv)
              jq '.tgv_iterations = 10 | .tgv_alpha1 = 0.0015 | .tgv_alpha2 = 0.0005' inputs_${algorithm}.json > temp.json && mv temp.json inputs_${algorithm}.json
              ;;
            qsm-rts|qsm-tv)
              jq '.unwrapping = "romeo" | .bf_algorithm = "vsharp"' inputs_${algorithm}.json > temp.json && mv temp.json inputs_${algorithm}.json
              ;;
          esac

          # Run the algorithm
          mkdir -p "results/${algorithm}/phantom"

          echo "Executing $algorithm..."
          echo "Input parameters:"
          cat "inputs_${algorithm}.json"

          # Run bosh exec and capture output
          timeout 3600 bosh exec launch \
            "${algorithm}.json" \
            "inputs_${algorithm}.json" \
            --imagepath "astewartau/${{ needs.build-image.outputs.imagename }}:testing" \
            --verbose 2>&1 | tee ${algorithm}_execution.log

          BOSH_EXIT_CODE=${PIPESTATUS[0]}

          # Check bosh exit code
          if [ $BOSH_EXIT_CODE -ne 0 ]; then
            echo "❌ $algorithm execution failed: bosh exec returned non-zero exit code: $BOSH_EXIT_CODE"
            echo "Last 50 lines of execution log:"
            tail -50 ${algorithm}_execution.log
            echo "test_result=FAIL" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Get output patterns from descriptor's evaluation config
          echo "Checking for expected output files using descriptor configuration..."

          # Extract output patterns from the descriptor
          OUTPUT_PATTERNS=$(jq -r '.custom."evaluation-config"."output-patterns"[]? // empty' "${algorithm}.json" 2>/dev/null)

          if [ -z "$OUTPUT_PATTERNS" ]; then
            echo "⚠️  No output patterns found in descriptor, using defaults"
            OUTPUT_PATTERNS="*chi*.nii* *Chimap*.nii* *qsm*.nii*"
          fi

          echo "Using output patterns: $OUTPUT_PATTERNS"

          # Look for QSM output files using patterns from descriptor
          QSM_OUTPUT=""
          for pattern in $OUTPUT_PATTERNS; do
            QSM_OUTPUT=$(find "results/${algorithm}/phantom" -name "$pattern" 2>/dev/null | head -1)
            if [ -n "$QSM_OUTPUT" ] && [ -f "$QSM_OUTPUT" ]; then
              echo "✓ Found QSM output matching pattern '$pattern': $QSM_OUTPUT"
              break
            fi
          done

          # Also try common QSM locations
          if [ -z "$QSM_OUTPUT" ]; then
            QSM_OUTPUT=$(find "results/${algorithm}/phantom" -path "*/derivatives/*/sub-*/anat/*Chimap.nii*" 2>/dev/null | head -1)
          fi
          if [ -z "$QSM_OUTPUT" ]; then
            QSM_OUTPUT=$(find "results/${algorithm}/phantom" -path "*/qsm/*chi*.nii*" 2>/dev/null | head -1)
          fi

          if [ -n "$QSM_OUTPUT" ] && [ -f "$QSM_OUTPUT" ]; then
            echo "✓ Found QSM output: $QSM_OUTPUT"
            echo "✅ $algorithm execution completed successfully"
            echo "test_result=PASS" >> $GITHUB_OUTPUT
          else
            echo "❌ No QSM output file found matching expected patterns"
            echo "Directory contents:"
            find "results/${algorithm}/phantom" -type f 2>/dev/null | head -10
            echo "test_result=FAIL" >> $GITHUB_OUTPUT
            exit 1
          fi

  aggregate-results:
    needs: [build-image, test-qsm-algorithms]
    if: always()  # Run even if some tests failed
    runs-on: ubuntu-22.04
    outputs:
      should_upload: ${{ steps.decide.outputs.should_upload }}
      container_tag: ${{ needs.build-image.outputs.container_tag }}
      imagename: ${{ needs.build-image.outputs.imagename }}
      builddate: ${{ needs.build-image.outputs.builddate }}
    steps:
      - name: Collect QSM test results
        id: collect
        run: |
          echo "Collecting results from all QSM algorithm tests..."

          # Get results from all matrix jobs - this gives us the overall result of the matrix job
          MATRIX_RESULT='${{ needs.test-qsm-algorithms.result }}'
          echo "QSM test matrix job overall result: $MATRIX_RESULT"

          # For matrix jobs, if the overall result is 'success', all matrix runs passed
          # If it's 'failure', at least one matrix run failed
          if [ "$MATRIX_RESULT" = "success" ]; then
            echo "✅ All QSM algorithm tests passed"
            echo "all_passed=true" >> $GITHUB_OUTPUT
          else
            echo "❌ Some QSM algorithm tests failed"
            echo "all_passed=false" >> $GITHUB_OUTPUT

            # The matrix job failed, but we don't have individual results here
            echo "Matrix job result: $MATRIX_RESULT"
          fi

      - name: Decide on upload
        id: decide
        run: |
          ALL_PASSED="${{ steps.collect.outputs.all_passed }}"

          if [ "$ALL_PASSED" = "true" ]; then
            echo "✅ All tests passed, will upload image"
            echo "should_upload=true" >> $GITHUB_OUTPUT
            echo "## ✅ QSM-CI Tests Passed" >> $GITHUB_STEP_SUMMARY
            echo "All algorithm tests completed successfully." >> $GITHUB_STEP_SUMMARY
            echo "Docker image will be uploaded to registry." >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ Tests failed, will NOT upload image"
            echo "should_upload=false" >> $GITHUB_OUTPUT
            echo "## ❌ QSM-CI Tests Failed" >> $GITHUB_STEP_SUMMARY
            echo "Some algorithm tests failed." >> $GITHUB_STEP_SUMMARY
            echo "Docker image will NOT be uploaded to registry." >> $GITHUB_STEP_SUMMARY
            exit 1
          fi


  cleanup:
    needs: [aggregate-results]
    if: always()
    runs-on: ubuntu-22.04
    steps:
      - name: Cleanup test images
        run: |
          echo "Cleaning up any temporary test images..."
          # This would clean up temporary testing images if they exist
          echo "Cleanup completed"