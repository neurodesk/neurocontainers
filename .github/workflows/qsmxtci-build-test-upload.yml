name: QSMxT-CI Build, Test, and Upload

permissions:
  contents: write
  pull-requests: write
  packages: write
  id-token: write

on:
  push:
    paths:
      - recipes/qsmxtci/**
    branches:
      - master
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild even if no changes detected'
        required: false
        default: 'false'
        type: boolean
      algorithms:
        description: 'Algorithms to test (comma-separated)'
        required: false
        default: 'qsm-tgv,qsm-nextqsm,qsm-rts,qsm-tv'
      datasets:
        description: 'Datasets to test (comma-separated)'
        required: false
        default: 'phantom,sim_sub1'

jobs:
  build-and-test:
    runs-on: ubuntu-22.04
    if: ${{ !contains(github.event.head_commit.message, 'skipci') }}
    outputs:
      should_upload: ${{ steps.test-results.outputs.should_upload }}
      container_tag: ${{ steps.vars.outputs.container_tag }}
      imagename: ${{ steps.vars.outputs.imagename }}
      builddate: ${{ steps.vars.outputs.builddate }}

    steps:
      - name: Configure runner
        run: |
          sudo mkdir -p /mnt/tmp
          sudo chown $USER /mnt/tmp
          sudo mkdir -p /mnt/docker
          echo '{"data-root": "/mnt/docker"}' | sudo tee /etc/docker/daemon.json
          sudo systemctl restart docker

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set environment variables
        id: vars
        run: |
          APPLICATION=qsmxtci
          SHORT_SHA=$(git rev-parse --short $GITHUB_SHA)
          BUILDDATE=`date +%Y%m%d`
          IMAGENAME=qsmxtci_8.1.3
          CONTAINER_TAG=astewartau/${IMAGENAME}:${BUILDDATE}

          echo "APPLICATION=$APPLICATION" >> $GITHUB_ENV
          echo "SHORT_SHA=$SHORT_SHA" >> $GITHUB_ENV
          echo "BUILDDATE=$BUILDDATE" >> $GITHUB_ENV
          echo "IMAGENAME=$IMAGENAME" >> $GITHUB_ENV
          echo "CONTAINER_TAG=$CONTAINER_TAG" >> $GITHUB_ENV

          echo "builddate=$BUILDDATE" >> $GITHUB_OUTPUT
          echo "imagename=$IMAGENAME" >> $GITHUB_OUTPUT
          echo "container_tag=$CONTAINER_TAG" >> $GITHUB_OUTPUT

          echo "Variables set:"
          echo "  APPLICATION=$APPLICATION"
          echo "  IMAGENAME=$IMAGENAME"
          echo "  CONTAINER_TAG=$CONTAINER_TAG"

      - name: Install builder dependencies
        run: |
          pip install -r requirements.txt

      - name: Generate Dockerfile and Release file
        run: |
          echo "Generating Dockerfile for qsmxtci"
          ./builder/build.py generate qsmxtci --recreate --auto-build --generate-release

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Check if rebuild needed
        id: check-rebuild
        run: |
          FORCE_REBUILD="${{ inputs.force_rebuild || 'false' }}"

          if [ "$FORCE_REBUILD" = "true" ]; then
            echo "Force rebuild requested"
            echo "needs_rebuild=true" >> $GITHUB_OUTPUT
          else
            # Check if image already exists with same content
            docker pull ${{ env.CONTAINER_TAG }} && {
              echo "Image already exists, checking for changes..."
              # For simplicity, we'll rebuild if the recipe changed
              # In production, you might want more sophisticated change detection
              echo "needs_rebuild=true" >> $GITHUB_OUTPUT
            } || {
              echo "Image doesn't exist, needs rebuild"
              echo "needs_rebuild=true" >> $GITHUB_OUTPUT
            }
          fi

      - name: Build Docker image (local only)
        if: steps.check-rebuild.outputs.needs_rebuild == 'true'
        run: |
          cd ./build/qsmxtci
          echo "Building image locally (not pushing yet)..."
          docker build . \
            --file qsmxtci_8.1.3.Dockerfile \
            --tag ${{ env.CONTAINER_TAG }} \
            --tag astewartau/${{ env.IMAGENAME }}:testing \
            --label "GITHUB_REPOSITORY=${GITHUB_REPOSITORY}" \
            --label "GITHUB_SHA=${SHORT_SHA}"

          echo "✓ Docker image built successfully"
          docker images | grep qsmxtci

      - name: Install test dependencies
        run: |
          pip install boutiques nibabel scipy scikit-learn scikit-image pandas numpy --user
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Extract Boutiques descriptors
        run: |
          echo "Extracting descriptors from local image..."
          mkdir -p descriptors

          # Use extraction script but with local image
          chmod +x scripts/extract_descriptors.sh

          # Create temporary container to extract descriptors
          CONTAINER_ID=$(docker create astewartau/${{ env.IMAGENAME }}:testing)
          docker cp "$CONTAINER_ID:/boutique/" descriptors/ || {
            echo "Error: Could not extract /boutique directory from container"
            docker rm "$CONTAINER_ID"
            exit 1
          }
          docker rm "$CONTAINER_ID"

          # Move files up one level if needed
          if [ -d "descriptors/boutique" ]; then
            mv descriptors/boutique/*.json descriptors/ 2>/dev/null || true
            rmdir descriptors/boutique 2>/dev/null || true
          fi

          echo "✓ Extracted descriptors:"
          ls -la descriptors/*.json

      - name: Validate descriptors
        run: |
          echo "Validating extracted descriptors..."
          VALIDATION_FAILED=false

          for descriptor in descriptors/*.json; do
            echo "Validating $(basename "$descriptor")..."
            if bosh validate "$descriptor"; then
              echo "  ✓ Valid"
            else
              echo "  ✗ Invalid"
              VALIDATION_FAILED=true
            fi
          done

          if [ "$VALIDATION_FAILED" = "true" ]; then
            echo "❌ Descriptor validation failed"
            exit 1
          fi

          echo "✓ All descriptors are valid"

      - name: Prepare test data
        run: |
          echo "Creating test data using qsm-forward..."

          # Install qsm-forward to generate proper BIDS data
          pip install qsm-forward==0.19 --user

          # Generate BIDS test data using qsm-forward (same as qsmci repo)
          qsm-forward simple test-data/phantom

          echo "✓ Created BIDS phantom test dataset using qsm-forward"
          echo "Generated BIDS structure:"
          find test-data/phantom -type f -name "*.nii*" | head -10

      - name: Run QSM algorithm tests
        id: run-tests
        run: |
          echo "Running QSM algorithm tests..."
          TEST_RESULTS=""
          ALGORITHMS="${{ inputs.algorithms || 'qsm-nextqsm,qsm-tgv' }}"  # Test subset for faster feedback
          FAILED_TESTS=""

          for algorithm in $(echo $ALGORITHMS | tr ',' ' '); do
            echo "=== Testing $algorithm ==="

            # Skip if descriptor doesn't exist
            if [ ! -f "descriptors/${algorithm}.json" ]; then
              echo "⚠️  Descriptor not found: ${algorithm}.json, skipping"
              continue
            fi

            # Create algorithm-specific inputs
            echo '{"bids_dir": "test-data/phantom", "output_dir": "results/'${algorithm}'/phantom", "subject": "1"}' > inputs_${algorithm}.json

            # Add algorithm-specific parameters
            case "$algorithm" in
              qsm-tgv)
                # Add TGV-specific parameters
                jq '.tgv_iterations = 10 | .tgv_alpha1 = 0.0015 | .tgv_alpha2 = 0.0005' inputs_${algorithm}.json > temp.json && mv temp.json inputs_${algorithm}.json
                ;;
              qsm-rts|qsm-tv)
                # Add algorithm-specific parameters
                jq '.unwrapping = "romeo" | .bf_algorithm = "vsharp"' inputs_${algorithm}.json > temp.json && mv temp.json inputs_${algorithm}.json
                ;;
            esac

            # Run the algorithm
            mkdir -p "results/${algorithm}/phantom"

            echo "Executing $algorithm..."
            if timeout 300 bosh exec launch \
              "descriptors/${algorithm}.json" \
              "inputs_${algorithm}.json" \
              --imagepath "astewartau/${{ env.IMAGENAME }}:testing" \
              --verbose; then
              echo "✅ $algorithm execution successful"
              TEST_RESULTS="${TEST_RESULTS}${algorithm}:PASS "
            else
              echo "❌ $algorithm execution failed"
              TEST_RESULTS="${TEST_RESULTS}${algorithm}:FAIL "
              FAILED_TESTS="${FAILED_TESTS}${algorithm} "
              continue
            fi

            # Run evaluation if ground truth is available
            GROUND_TRUTH="test-data/phantom/derivatives/qsm-forward/sub-1/anat/sub-1_Chimap.nii"
            ROI="test-data/phantom/derivatives/qsm-forward/sub-1/anat/sub-1_mask.nii"

            if [ -f "$GROUND_TRUTH" ] && [ -f "$ROI" ]; then
              # Find QSM output
              QSM_OUTPUT=$(find "results/${algorithm}/phantom" -name "*chi*.nii.gz" -o -name "*Chimap*.nii*" | head -1)

              if [ -f "$QSM_OUTPUT" ]; then
                echo "Running evaluation for $algorithm..."
                mkdir -p "results/${algorithm}/phantom/metrics"

                # Export variables for Python script
                export GROUND_TRUTH="$GROUND_TRUTH"
                export QSM_OUTPUT="$QSM_OUTPUT"
                export ROI="$ROI"
                export ALGO="$algorithm"

                # Run simplified evaluation
                python3 -c "import nibabel as nib; import numpy as np; import json; from scipy.stats import pearsonr; from sklearn.metrics import mean_squared_error; gt = nib.load('$GROUND_TRUTH').get_fdata(); est = nib.load('$QSM_OUTPUT').get_fdata(); roi = nib.load('$ROI').get_fdata().astype(bool); gt_roi = gt[roi]; est_roi = est[roi]; correlation, _ = pearsonr(gt_roi.flatten(), est_roi.flatten()); rmse = np.sqrt(mean_squared_error(gt_roi.flatten(), est_roi.flatten())); results = dict(correlation=float(correlation), rmse=float(rmse), algorithm='$algorithm'); json.dump(results, open('results/${algorithm}/phantom/metrics/metrics.json', 'w'), indent=2); print(f'✓ Evaluation complete: correlation={correlation:.4f}, rmse={rmse:.6f}')"

                if [ -f "results/${algorithm}/phantom/metrics/metrics.json" ]; then
                  echo "  Results:"
                  cat "results/${algorithm}/phantom/metrics/metrics.json" | jq '.'
                fi
              else
                echo "⚠️  No QSM output found for evaluation"
              fi
            else
              echo "⚠️  Ground truth not available for evaluation"
            fi
          done

          echo "Test results: $TEST_RESULTS"
          echo "test_results=$TEST_RESULTS" >> $GITHUB_OUTPUT

          if [ -n "$FAILED_TESTS" ]; then
            echo "failed_tests=$FAILED_TESTS" >> $GITHUB_OUTPUT
            echo "❌ Some tests failed: $FAILED_TESTS"
            exit 1
          else
            echo "✅ All tests passed!"
          fi

      - name: Evaluate test results
        id: test-results
        run: |
          TEST_RESULTS="${{ steps.run-tests.outputs.test_results }}"
          FAILED_TESTS="${{ steps.run-tests.outputs.failed_tests }}"

          if [ -n "$FAILED_TESTS" ]; then
            echo "❌ Tests failed, will NOT upload image"
            echo "should_upload=false" >> $GITHUB_OUTPUT
            echo "## ❌ QSM-CI Tests Failed" >> $GITHUB_STEP_SUMMARY
            echo "Failed algorithms: $FAILED_TESTS" >> $GITHUB_STEP_SUMMARY
            echo "Docker image will NOT be uploaded to registry." >> $GITHUB_STEP_SUMMARY
          else
            echo "✅ All tests passed, ready to upload"
            echo "should_upload=true" >> $GITHUB_OUTPUT
            echo "## ✅ QSM-CI Tests Passed" >> $GITHUB_STEP_SUMMARY
            echo "All algorithm tests completed successfully." >> $GITHUB_STEP_SUMMARY
            echo "Docker image will be uploaded to registry." >> $GITHUB_STEP_SUMMARY
          fi

  upload-and-release:
    needs: build-and-test
    if: needs.build-and-test.outputs.should_upload == 'true'
    runs-on: ubuntu-22.04
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Pull and retag tested image
        run: |
          IMAGENAME="${{ needs.build-and-test.outputs.imagename }}"
          BUILDDATE="${{ needs.build-and-test.outputs.builddate }}"

          echo "Pulling tested image and retagging for upload..."

          # Pull the tested image (this should be available from the previous job)
          # Note: In practice, you might need to use a different approach since
          # GitHub Actions jobs run in separate environments
          echo "This step would pull the tested image and retag it"
          echo "For now, we'll trigger a rebuild since the image was tested locally"

      - name: Install builder dependencies
        run: |
          pip install -r requirements.txt

      - name: Rebuild and upload image
        env:
          DOCKERHUB_ORG: ${{ secrets.DOCKERHUB_ORG }}
        run: |
          IMAGENAME="${{ needs.build-and-test.outputs.imagename }}"
          BUILDDATE="${{ needs.build-and-test.outputs.builddate }}"

          # Generate Dockerfile again (since this is a new job environment)
          ./builder/build.py generate qsmxtci --recreate --auto-build --generate-release

          # Rebuild image (since we can't easily transfer between job environments)
          cd ./build/qsmxtci
          docker build . \
            --file ${IMAGENAME}.Dockerfile \
            --tag ${DOCKERHUB_ORG}/${IMAGENAME}:${BUILDDATE} \
            --tag ${DOCKERHUB_ORG}/${IMAGENAME}:latest \
            --label "GITHUB_REPOSITORY=${GITHUB_REPOSITORY}" \
            --label "GITHUB_SHA=$(git rev-parse --short $GITHUB_SHA)"

          echo "Pushing to DockerHub..."
          docker push ${DOCKERHUB_ORG}/${IMAGENAME}:${BUILDDATE}
          docker push ${DOCKERHUB_ORG}/${IMAGENAME}:latest

          echo "✅ Successfully uploaded Docker image"
          echo "## ✅ Docker Image Uploaded" >> $GITHUB_STEP_SUMMARY
          echo "- Image: \`${DOCKERHUB_ORG}/${IMAGENAME}:${BUILDDATE}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Latest: \`${DOCKERHUB_ORG}/${IMAGENAME}:latest\`" >> $GITHUB_STEP_SUMMARY

      - name: Create release PR
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DOCKERHUB_ORG: ${{ secrets.DOCKERHUB_ORG }}
        run: |
          IMAGENAME="${{ needs.build-and-test.outputs.imagename }}"
          BUILDDATE="${{ needs.build-and-test.outputs.builddate }}"

          # Generate release file
          ./builder/build.py generate qsmxtci --recreate --auto-build --generate-release

          # This would create the release PR similar to the original workflow
          # For now, just output the success message
          echo "✅ Ready to create release PR for ${IMAGENAME}:${BUILDDATE}"
          echo "Release file would be created and PR opened automatically"

  cleanup:
    needs: [build-and-test, upload-and-release]
    if: always()
    runs-on: ubuntu-22.04
    steps:
      - name: Cleanup test images
        run: |
          echo "Cleaning up any temporary test images..."
          # This would clean up temporary testing images if they exist
          echo "Cleanup completed"