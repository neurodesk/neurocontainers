name: build-app

on:
  workflow_call:
    inputs:
      application:
        required: true
        type: string
      runner:
        required: true
        type: string

env:
  GH_REGISTRY: ${{ secrets.GH_REGISTRY }}
  DOCKERHUB_ORG: ${{ secrets.DOCKERHUB_ORG }}
  OS_PASSWORD: ${{ secrets.SWIFT_OS_PASSWORD }}
  OS_PROJECT_ID: ${{ secrets.SWIFT_OS_PROJECT_ID }}
  OS_USERNAME: ${{ secrets.SWIFT_OS_USERNAME }}
  OS_APPLICATION_CREDENTIAL_ID: ${{ secrets.SWIFT_OS_APPLICATION_CREDENTIAL_ID }}
  OS_APPLICATION_CREDENTIAL_SECRET: ${{ secrets.SWIFT_OS_APPLICATION_CREDENTIAL_SECRET }}

jobs:
  build-image:
    runs-on: ${{ inputs.runner }}

    permissions:
      packages: write
      id-token: write
      contents: write

    outputs:
      APPLICATION: ${{ steps.ENVVARS.outputs.APPLICATION }}
      IMAGENAME: ${{ steps.IMAGEVARS.outputs.IMAGENAME }}
      BUILDDATE: ${{ steps.ENVVARS.outputs.BUILDDATE }}
      PUSHIMAGE: ${{ steps.compareimages.outputs.PUSHIMAGE }}

    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683
        with:
          token: ${{ secrets.NEURODESK_GITHUB_TOKEN_ISSUE_AUTOMATION }}

      - name: Set environment variables
        id: ENVVARS
        run: |
          APPLICATION=${{ inputs.application }}
          SHORT_SHA=$(git rev-parse --short $GITHUB_SHA)
          BUILDDATE=`date +%Y%m%d`
          echo "APPLICATION=$APPLICATION" >> $GITHUB_ENV
          echo "APPLICATION=$APPLICATION" >> $GITHUB_OUTPUT
          echo "SHORT_SHA=$SHORT_SHA" >> $GITHUB_ENV
          echo "BUILDDATE=$BUILDDATE" >> $GITHUB_ENV
          echo "BUILDDATE=$BUILDDATE" >> $GITHUB_OUTPUT

      - name: Configure runner
        run: |
          sudo mkdir -p /mnt/tmp
          sudo chown $USER /mnt/tmp
          sudo mkdir -p /mnt/docker
          echo '{"data-root": "/mnt/docker"}' | sudo tee /etc/docker/daemon.json
          sudo systemctl restart docker

      - name: Install builder dependencies
        run: |
          pip install -r requirements.txt

      - name: Generate Dockerfile and Release file
        id: generate
        run: |
          echo "APPLICATION: $APPLICATION"
          ./builder/build.py generate $APPLICATION --recreate --auto-build --generate-release

      - name: Set image variables
        id: IMAGEVARS
        run: |
          DOCKERFILE=`basename $(find ./build/$APPLICATION/ -type f -iname "*.Dockerfile" | head -1)`
          # if the dockerfile is not found, exit with error
          if [ -z "$DOCKERFILE" ]; then
            echo "Dockerfile not found for $APPLICATION"
            exit 1
          fi
          IMAGENAME=$(echo $(basename $DOCKERFILE .Dockerfile) | tr '[A-Z]' '[a-z]')
          IMAGEID=ghcr.io/${{ secrets.GH_REGISTRY }}/$IMAGENAME
          IMAGEID=$(echo $IMAGEID | tr '[A-Z]' '[a-z]')  
          echo "IMAGENAME: $IMAGENAME"
          echo "IMAGEID: $IMAGEID"
          echo "IMAGENAME_TEST=${IMAGENAME//_/ }" >> $GITHUB_ENV
          echo "test command: bash /neurocommand/local/fetch_and_run.sh ${IMAGENAME//_/ } $BUILDDATE"
          echo "IMAGENAME=$IMAGENAME" >> $GITHUB_ENV
          echo "IMAGENAME=$IMAGENAME" >> $GITHUB_OUTPUT
          echo "IMAGEID=$IMAGEID" >> $GITHUB_ENV

      - name: Login to GHCR
        uses: docker/login-action@74a5d142397b4f367a81961eba4e8cd7edddf772
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435

      - name: Pull latest image from registry and get rootfs
        run: |
          docker pull $IMAGEID:latest && ROOTFS_CACHE=$(docker inspect --format='{{.RootFS}}' $IMAGEID:latest) || true
          echo "ROOTFS_CACHE=$ROOTFS_CACHE" >> $GITHUB_ENV

      - name: Build and save new image 
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83
        with:
          context: ./build/${{ env.APPLICATION }}
          file: ./build/${{ env.APPLICATION }}/${{ env.IMAGENAME }}.Dockerfile
          push: false
          load: true
          tags: ${{ env.IMAGEID }}:${{ env.BUILDDATE }}
          cache-from: type=registry,ref=${{ env.IMAGEID }}:latest
          cache-to: type=inline
          outputs: type=docker,dest=/mnt/tmp/${{ env.APPLICATION }}-${{ env.BUILDDATE }}.tar

      - name: Compare new and cached images
        id: compareimages
        run: |
          docker images -a
          ROOTFS_NEW=$(docker inspect --format='{{.RootFS}}' ${{ env.IMAGEID }}:${{ env.BUILDDATE }})
          echo "ROOTFS_NEW=$ROOTFS_NEW" >> $GITHUB_ENV

          if [ "$ROOTFS_NEW" = "$ROOTFS_CACHE" ]; then
            echo "Skipping push to registry. No changes found"
          else
            echo "Pushing to registry. Changes found"
            echo "PUSHIMAGE=true" >> $GITHUB_ENV
          fi

      - name: Upload new image as build artifact (if changes found)
        if: ${{ steps.compareimages.outputs.PUSHIMAGE == 'true' }}
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: ${{ env.APPLICATION }}-${{ env.BUILDDATE }}
          path: /mnt/tmp/${{ env.APPLICATION }}-${{ env.BUILDDATE }}.tar
          retention-days: 1
  
  push-ghcr:
    needs: build-image
    if: ${{ needs.build-image.outputs.PUSHIMAGE == 'true' }}
    runs-on: ${{ inputs.runner }}
    permissions:
      packages: write

    steps:
      - name: Configure runner
        run: |
          sudo mkdir -p /mnt/tmp
          sudo chown $USER /mnt/tmp
          sudo mkdir -p /mnt/docker
          echo '{"data-root": "/mnt/docker"}' | sudo tee /etc/docker/daemon.json
          sudo systemctl restart docker

      - name: Download build artifact
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          name: ${{ needs.build-image.outputs.APPLICATION }}-${{ needs.build-image.outputs.BUILDDATE }}
          path: /mnt/tmp

      - name: Load Docker Image from Artifact
        run: docker load --input /mnt/tmp/${{ needs.build-image.outputs.APPLICATION }}-${{ needs.build-image.outputs.BUILDDATE }}.tar

      - name: Login to GHCR
        uses: docker/login-action@74a5d142397b4f367a81961eba4e8cd7edddf772
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Push to GHCR
        run: |
          docker tag ghcr.io/$GITHUB_REPOSITORY/${{ needs.build-image.outputs.IMAGENAME }}:${{ needs.build-image.outputs.BUILDDATE }} ghcr.io/$GITHUB_REPOSITORY/${{ needs.build-image.outputs.IMAGENAME }}:latest
          docker push --all-tags ghcr.io/$GITHUB_REPOSITORY/${{ needs.build-image.outputs.IMAGENAME }}

  push-dockerhub:
    needs: build-image
    if: ${{ needs.build-image.outputs.PUSHIMAGE == 'true' }}
    runs-on: ${{ inputs.runner }}
    permissions:
      packages: write

    steps:
      - name: Configure runner
        run: |
          sudo mkdir -p /mnt/tmp
          sudo chown $USER /mnt/tmp
          sudo mkdir -p /mnt/docker
          echo '{"data-root": "/mnt/docker"}' | sudo tee /etc/docker/daemon.json
          sudo systemctl restart docker

      - name: Download image artifact
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          name: ${{ needs.build-image.outputs.APPLICATION }}-${{ needs.build-image.outputs.BUILDDATE }}
          path: /mnt/tmp

      - name: Load Docker Image from Artifact
        run: docker load --input /mnt/tmp/${{ needs.build-image.outputs.APPLICATION }}-${{ needs.build-image.outputs.BUILDDATE }}.tar

      - name: Login to DockerHub
        uses: docker/login-action@74a5d142397b4f367a81961eba4e8cd7edddf772
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}
      - name: Push to DockerHub
        run: |
          docker tag ghcr.io/$GITHUB_REPOSITORY/${{ needs.build-image.outputs.IMAGENAME }}:${{ needs.build-image.outputs.BUILDDATE }} ${{ secrets.DOCKERHUB_ORG }}/${{ needs.build-image.outputs.IMAGENAME }}:${{ needs.build-image.outputs.BUILDDATE }}
          docker tag ghcr.io/$GITHUB_REPOSITORY/${{ needs.build-image.outputs.IMAGENAME }}:${{ needs.build-image.outputs.BUILDDATE }} ${{ secrets.DOCKERHUB_ORG }}/${{ needs.build-image.outputs.IMAGENAME }}:latest
          docker push --all-tags ${{ secrets.DOCKERHUB_ORG }}/${{ needs.build-image.outputs.IMAGENAME }}

  build-simg:
    needs: build-image
    if: ${{ needs.build-image.outputs.PUSHIMAGE == 'true' }}
    runs-on: ${{ inputs.runner }}
    permissions:
      packages: write
    outputs:
      APPLICATION: ${{ needs.build-image.outputs.APPLICATION }}
      IMAGENAME: ${{ needs.build-image.outputs.IMAGENAME }}
      BUILDDATE: ${{ needs.build-image.outputs.BUILDDATE }}
      PUSHIMAGE: ${{ needs.build-image.outputs.PUSHIMAGE }}

    steps:
      - name: Configure runner
        run: |
          sudo mkdir -p /mnt/tmp
          sudo chown $USER /mnt/tmp
          sudo mkdir -p /mnt/docker
          echo '{"data-root": "/mnt/docker"}' | sudo tee /etc/docker/daemon.json
          sudo systemctl restart docker

          sudo mkdir -p /mnt/apptainer/cache
          sudo chown $USER /mnt/apptainer/cache
          APPTAINER_CACHEDIR=/mnt/apptainer/cache
          echo "APPTAINER_CACHEDIR=$APPTAINER_CACHEDIR" >> $GITHUB_ENV

          sudo apt-get install -y software-properties-common
          sudo add-apt-repository -y ppa:apptainer/ppa
          sudo apt-get update
          sudo apt-get install -y apptainer

          # sudo mkdir -p /mnt/apptainer
          # sudo chown $USER /mnt/apptainer
          # git clone https://github.com/apptainer/apptainer.git /mnt/apptainer
          # cd /mnt/apptainer
          # ./mconfig --prefix=/mnt/apptainer
          # make -C builddir
          # sudo make -C builddir install
          # export PATH="/mnt/apptainer/bin:$PATH"
          # echo "/mnt/apptainer/bin" >> $GITHUB_PATH

      - name: Download image artifact
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          name: ${{ needs.build-image.outputs.APPLICATION }}-${{ needs.build-image.outputs.BUILDDATE }}
          path: /mnt/tmp

      - name: Load Docker Image from Artifact
        run: docker load --input /mnt/tmp/${{ needs.build-image.outputs.APPLICATION }}-${{ needs.build-image.outputs.BUILDDATE }}.tar

      - name: Build simg file
        run: |
          echo "[DEBUG] building singularity image from docker image:"
          time singularity build "/mnt/tmp/${{ needs.build-image.outputs.IMAGENAME }}_${{ needs.build-image.outputs.BUILDDATE }}.simg" docker-daemon://ghcr.io/$GITHUB_REPOSITORY/${{ needs.build-image.outputs.IMAGENAME }}:${{ needs.build-image.outputs.BUILDDATE }}
          echo "[DEBUG] done building singularity image from docker image!"
  
      - name: Upload simg artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: ${{ needs.build-image.outputs.IMAGENAME }}_${{ needs.build-image.outputs.BUILDDATE }}.simg
          path: /mnt/tmp/${{ needs.build-image.outputs.IMAGENAME }}_${{ needs.build-image.outputs.BUILDDATE }}.simg
          retention-days: 1

  upload-nectar:
    needs: build-simg
    if: ${{ needs.build-simg.outputs.PUSHIMAGE == 'true' }}
    runs-on: ${{ inputs.runner }}
    permissions:
      packages: write

    steps:
      - name: Configure runner
        run: |
          sudo mkdir -p /mnt/tmp
          sudo chown $USER /mnt/tmp
          
      - name: Download simg artifact
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          name: ${{ needs.build-simg.outputs.IMAGENAME }}_${{ needs.build-simg.outputs.BUILDDATE }}.simg
          path: /mnt/tmp/${{ needs.build-simg.outputs.IMAGENAME }}_${{ needs.build-simg.outputs.BUILDDATE }}.simg

      - name: Upload simg to Nectar
        run: |
          echo "[DEBUG] Attempting upload to Nectar Object Storage:"
          time rclone copy /mnt/tmp/${{ needs.build-simg.outputs.IMAGENAME }}_${{ needs.build-simg.outputs.BUILDDATE }}.simg nectar:/neurodesk/temporary-builds-new
          echo "[DEBUG] Done with uploading to Nectar Object Storage!"
  
  upload-s3:
    needs: build-simg
    if: ${{ needs.build-simg.outputs.PUSHIMAGE == 'true' }}
    runs-on: ${{ inputs.runner }}
    permissions:
      packages: write
    steps:
      - name: Configure runner
        run: |
          sudo mkdir -p /mnt/tmp
          sudo chown $USER /mnt/tmp

      - name: Configure aws credentials
        uses: aws-actions/configure-aws-credentials@ececac1a45f3b08a01d2dd070d28d111c5fe6722
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-east-2
      - name: Download simg artifact
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093
        with:
          name: ${{ needs.build-simg.outputs.IMAGENAME }}_${{ needs.build-simg.outputs.BUILDDATE }}.simg
          path: /mnt/tmp/${{ needs.build-simg.outputs.IMAGENAME }}_${{ needs.build-simg.outputs.BUILDDATE }}.simg

      - name: Install AWS CLI
        run: |
          if ! command -v aws &>/dev/null; then
            echo "[DEBUG] Installing AWS CLI"
            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip" && unzip awscliv2.zip && sudo ./aws/install && rm -rf aws awscliv2.zip
          fi

      - name: Upload to AWS S3
        run: time aws s3 cp /mnt/tmp/${{ needs.build-simg.outputs.IMAGENAME }}_${{ needs.build-simg.outputs.BUILDDATE }}.simg s3://neurocontainers/temporary-builds-new/${{ needs.build-simg.outputs.IMAGENAME }}_${{ needs.build-simg.outputs.BUILDDATE }}.simg

  create-pr:
    needs: [build-image, push-ghcr, push-dockerhub, build-simg, upload-nectar, upload-s3]
    if: ${{ needs.build-image.outputs.PUSHIMAGE == 'true' }}
    runs-on: ${{ inputs.runner }}
    permissions:
      packages: write
      id-token: write
      contents: read
    steps:
    - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683
      with:
        token: ${{ secrets.NEURODESK_GITHUB_TOKEN_ISSUE_AUTOMATION }}
    - name: Set environment variables
      id: ENVVARS
      run: |
        APPLICATION=${{ inputs.application }}
        SHORT_SHA=$(git rev-parse --short $GITHUB_SHA)
        BUILDDATE=`date +%Y%m%d`
        echo "APPLICATION=$APPLICATION" >> $GITHUB_ENV
        echo "SHORT_SHA=$SHORT_SHA" >> $GITHUB_ENV
        echo "BUILDDATE=$BUILDDATE" >> $GITHUB_ENV
        echo "BUILDDATE=$BUILDDATE" >> $GITHUB_OUTPUT
    - name: Install Builder Dependencies
      run: |
        pip install -r requirements.txt
    - name: Generate Dockerfile and Release File
      id: generate
      run: |
        echo "APPLICATION: $APPLICATION"
        ./builder/build.py generate $APPLICATION --recreate --auto-build --generate-release

    - name: Create Release File Pull Request
      if: steps.generate.outputs.container_name
      env:
        GH_TOKEN: ${{ secrets.NEURODESK_GITHUB_TOKEN_ISSUE_AUTOMATION }}
        CONTAINER_NAME: ${{ steps.generate.outputs.container_name }}
        CONTAINER_VERSION: ${{ steps.generate.outputs.container_version }}
        RELEASE_CONTENT: ${{ steps.generate.outputs.release_file_content }}
      run: |
        gh auth setup-git

        # Configure git
        git config --global user.name "neurocontainers-bot"
        git config --global user.email "neurocontainers-bot@neurodesk.github.io"

        # Create a new branch for the release
        BRANCH_NAME="release/${CONTAINER_NAME}-${CONTAINER_VERSION}-$(date +%Y%m%d-%H%M%S)"
        git checkout -b "$BRANCH_NAME"

        # Create the release file
        RELEASE_DIR="releases/${CONTAINER_NAME}"
        RELEASE_FILE="${RELEASE_DIR}/${CONTAINER_VERSION}.json"

        mkdir -p "$RELEASE_DIR"
        echo "$RELEASE_CONTENT" > "$RELEASE_FILE"

        # Check if this is a new file or an update
        if git ls-files --error-unmatch "$RELEASE_FILE" 2>/dev/null; then
          ACTION="Update"
        else
          ACTION="Add"
        fi

        # Add and commit the release file
        git add "$RELEASE_FILE"
        git commit -m "${ACTION} release file for ${CONTAINER_NAME} ${CONTAINER_VERSION}

        Auto-generated release file from container build.

        ðŸ¤– Generated by neurocontainers CI"

        # Push the branch
        git push origin "$BRANCH_NAME"

        # Create pull request
        gh pr create \
          --title "${ACTION} release for ${CONTAINER_NAME} ${CONTAINER_VERSION}" \
          --body "## Summary

        This PR ${ACTION,,}s the release file for **${CONTAINER_NAME} ${CONTAINER_VERSION}**.

        ## Changes

        - ${ACTION} \`${RELEASE_FILE}\` with container metadata
        - Generated automatically from successful container build
        - Contains categories and GUI applications from build.yaml

        ## Testing Instructions

        To test this container on Neurodesk (either a local installation or https://play.neurodesk.org/):
        \`\`\`bash
        bash /neurocommand/local/fetch_and_run.sh ${IMAGENAME//_/ } ${BUILDDATE}
        \`\`\`

        Or, for testing directly with Apptainer/Singularity:
        \`\`\`bash
        curl -X GET https://neurocontainers.neurodesk.org/temporary-builds-new/${IMAGENAME}_${BUILDDATE}.simg -O
        singularity shell --overlay /tmp/apptainer_overlay ${IMAGENAME}_${BUILDDATE}.simg
        \`\`\`

        ## Review Checklist

        - [ ] Release file format is correct
        - [ ] Categories are appropriate for this container
        - [ ] GUI applications (if any) are correctly defined
        - [ ] Version and build date are accurate
        - [ ] Container has been tested using the commands above

        ## Next Steps

        After merging this PR:
        1. The apps.json update workflow will automatically regenerate apps.json from all release files
        2. A PR will be created to the neurocommand repository
        3. The container will become available in neurodesk

        If additional releases are needed:
        - Add to apps.json to release to Neurodesk: https://github.com/NeuroDesk/neurocommand/edit/main/neurodesk/apps.json
        - Or add to the Open Recon recipes: https://github.com/NeuroDesk/openrecon/tree/main/recipes

        ðŸ¤– Generated by neurocontainers CI | Created by @${GITHUB_ACTOR}" \
          --head "$BRANCH_NAME" \
          --base main \
          --label "automated" \
          --label "release"

        echo "âœ… Pull request created for ${CONTAINER_NAME} ${CONTAINER_VERSION}"
    - name: Generate job output
      run: |
        echo "The container has been successfully build. To test the container, run this:" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY # this is a blank line
        echo "bash /neurocommand/local/fetch_and_run.sh ${IMAGENAME//_/ } $BUILDDATE" >> $GITHUB_STEP_SUMMARY
