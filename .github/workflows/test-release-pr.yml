name: Test Release PR Containers

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - "releases/*/**.json"
      - "recipes/**/test.yaml"
    branches:
      - master
      - main

permissions:
  contents: read
  pull-requests: write
  id-token: write

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      modified-releases: ${{ steps.detect.outputs.modified-releases }}
      has-changes: ${{ steps.detect.outputs.has-changes }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect release and test-only changes
        id: detect
        env:
          BASE_REF: ${{ github.base_ref }}
        run: |
          python - <<'PY'
          import json
          import os
          import re
          import subprocess
          import sys
          from pathlib import Path

          def find_latest_release_file(release_dir: Path):
              if not release_dir.is_dir():
                  return None, None

              latest_path = None
              latest_build_date = ""
              latest_version = ""

              for entry in sorted(release_dir.iterdir()):
                  if entry.suffix != ".json":
                      continue

                  candidate_version = entry.stem
                  build_date = ""

                  try:
                      data = json.loads(entry.read_text(encoding="utf-8"))
                      apps = data.get("apps", {}) or {}
                      if apps:
                          first_value = next(iter(apps.values()))
                          build_date = str(first_value.get("version", "")).strip()
                  except Exception:
                      build_date = ""

                  if latest_path is None:
                      latest_path = entry
                      latest_build_date = build_date
                      latest_version = candidate_version
                      continue

                  if build_date and (not latest_build_date or build_date > latest_build_date):
                      latest_path = entry
                      latest_build_date = build_date
                      latest_version = candidate_version
                  elif build_date == latest_build_date and candidate_version > latest_version:
                      latest_path = entry
                      latest_version = candidate_version

              return latest_path, latest_version

          diff_range = f"origin/{os.environ['BASE_REF']}...HEAD"
          proc = subprocess.run(
              ["git", "diff", "--name-only", diff_range],
              check=False,
              capture_output=True,
              text=True,
          )
          if proc.returncode != 0:
              print(proc.stderr.strip(), file=sys.stderr)
              raise SystemExit(proc.returncode)

          changed_files = [line.strip() for line in proc.stdout.splitlines() if line.strip()]
          release_pattern = re.compile(r"^releases/([^/]+)/([^/]+)\.json$")
          test_pattern = re.compile(r"^recipes/([^/]+)/test\.yaml$")

          entries = {}

          for path in changed_files:
              match = release_pattern.match(path)
              if not match:
                  continue

              recipe, version = match.groups()
              entries[recipe] = {
                  "name": recipe,
                  "version": version,
                  "file": path,
              }

          missing_release = []
          for path in changed_files:
              match = test_pattern.match(path)
              if not match:
                  continue

              recipe = match.group(1)
              if recipe in entries:
                  continue

              release_file, version = find_latest_release_file(Path("releases") / recipe)
              if release_file and version:
                  entries[recipe] = {
                      "name": recipe,
                      "version": version,
                      "file": release_file.as_posix(),
                  }
              else:
                  missing_release.append(recipe)

          matrix = sorted(entries.values(), key=lambda item: item["name"])

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as handle:
              handle.write(f"has-changes={'true' if matrix else 'false'}\n")
              handle.write(f"modified-releases={json.dumps(matrix)}\n")

          if missing_release:
              unique_missing = sorted(set(missing_release))
              print(
                  "Missing release metadata for recipes with changed test.yaml: "
                  + ", ".join(unique_missing),
                  file=sys.stderr,
              )
              raise SystemExit(1)
          PY

  test-containers:
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    runs-on: self-hosted
    strategy:
      fail-fast: false
      matrix:
        release: ${{ fromJson(needs.detect-changes.outputs.modified-releases) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Verify container runtimes
        run: |
          # Verify that container runtimes are available on self-hosted runner
          docker --version
          apptainer --version || singularity --version

      - name: Debug matrix values
        run: |
          echo "Matrix release data:"
          echo "Name: ${{ matrix.release.name }}"
          echo "Version: ${{ matrix.release.version }}"
          echo "File: ${{ matrix.release.file }}"
          echo "Current directory: $(pwd)"
          echo "Release file exists: $([ -f '${{ matrix.release.file }}' ] && echo 'yes' || echo 'no')"

      - name: Find test configuration
        id: find-tests
        run: |
          # Look for test configuration in recipe directory
          RECIPE_DIR="recipes/${{ matrix.release.name }}"
          TEST_CONFIG=""

          if [ -f "$RECIPE_DIR/test.yaml" ]; then
            TEST_CONFIG="$RECIPE_DIR/test.yaml"
            echo "Found test.yaml"
          elif [ -f "$RECIPE_DIR/build.yaml" ]; then
            TEST_CONFIG="$RECIPE_DIR/build.yaml"
            echo "Found build.yaml (will extract tests from build directives)"
          else
            echo "No test configuration found in $RECIPE_DIR"
            ls -la "$RECIPE_DIR" || echo "Recipe directory not found"
          fi

          echo "test-config=$TEST_CONFIG" >> $GITHUB_OUTPUT

      - name: Run container tests
        id: test
        env:
          RECIPE: ${{ matrix.release.name }}
          VERSION: ${{ matrix.release.version }}
          RELEASE_FILE: ${{ matrix.release.file }}
          TEST_CONFIG: ${{ steps.find-tests.outputs.test-config }}
        run: |
          echo "Testing container: ${RECIPE}:${VERSION}"
          echo "Release file: ${RELEASE_FILE}"
          echo "Test config: ${TEST_CONFIG}"

          mkdir -p builder

          python - <<'PY'
          from pathlib import Path
          import os

          from workflows.test_runner import ContainerTestRunner, TestRequest

          recipe = os.environ["RECIPE"]
          version = os.environ.get("VERSION") or None
          release_file = os.environ.get("RELEASE_FILE") or None
          test_config = os.environ.get("TEST_CONFIG") or None

          runner = ContainerTestRunner()
          request = TestRequest(
              recipe=recipe,
              version=version,
              release_file=release_file,
              test_config=test_config if test_config else None,
              runtime="apptainer",
              location="auto",
              cleanup=True,
              auto_cleanup=False,
              verbose=True,
              allow_missing_tests=True,
              output_dir=Path("builder"),
              results_path=Path(f"builder/test-results-{recipe}.json"),
          )

          outcome = runner.run(request)
          print(f"Status: {outcome.status}")
          if outcome.reason:
              print(f"Reason: {outcome.reason}")

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as handle:
              handle.write(f"status={outcome.status}\n")
              if outcome.reason:
                  handle.write(f"reason={outcome.reason}\n")

          import sys
          sys.exit(0 if outcome.status != "failed" else 1)
          PY
        continue-on-error: true

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.release.name }}
          path: |
            builder/test-results-${{ matrix.release.name }}.json
            builder/test-report-${{ matrix.release.name }}.md

      - name: Comment test results on PR
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const releaseName = '${{ matrix.release.name }}';
            const releaseVersion = '${{ matrix.release.version }}';
            const reportFile = `builder/test-report-${releaseName}.md`;

            let reportContent = `## Test Results for ${releaseName}:${releaseVersion}\n\n`;

            try {
              if (fs.existsSync(reportFile)) {
                reportContent = fs.readFileSync(reportFile, 'utf8');
              } else {
                reportContent += "âŒ Test report not generated - check logs for errors.";
              }
            } catch (error) {
              reportContent += `âŒ Error reading test report: ${error.message}`;
            }

            // Find existing comment for this release
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.data.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes(`Test Results for ${releaseName}:${releaseVersion}`)
            );

            const commentBody = `${reportContent}\n\n---\n*Automated test results for container: ${releaseName}:${releaseVersion}*`;

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: commentBody
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
            }

  summarize-results:
    needs: [detect-changes, test-containers]
    if: always() && needs.detect-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download all test results
        uses: actions/download-artifact@v4
        with:
          pattern: test-results-*
          merge-multiple: true
          path: test-results

      - name: Summarize test results
        id: summary
        run: |
          cd test-results

          TOTAL_RECIPES=0
          PASSED_RECIPES=0
          FAILED_RECIPES=0

          for file in test-results-*.json; do
            if [ -f "$file" ]; then
              TOTAL_RECIPES=$((TOTAL_RECIPES + 1))
              
              # Check if any tests failed
              FAILED_TESTS=$(jq '.failed' "$file" 2>/dev/null || echo "1")
              if [ "$FAILED_TESTS" -eq 0 ]; then
                PASSED_RECIPES=$((PASSED_RECIPES + 1))
              else
                FAILED_RECIPES=$((FAILED_RECIPES + 1))
              fi
            fi
          done

          echo "total=$TOTAL_RECIPES" >> $GITHUB_OUTPUT
          echo "passed=$PASSED_RECIPES" >> $GITHUB_OUTPUT
          echo "failed=$FAILED_RECIPES" >> $GITHUB_OUTPUT

          echo "Test Summary: $PASSED_RECIPES/$TOTAL_RECIPES recipes passed"

      - name: Set PR status
        uses: actions/github-script@v7
        with:
          script: |
            const total = parseInt('${{ steps.summary.outputs.total }}');
            const passed = parseInt('${{ steps.summary.outputs.passed }}');
            const failed = parseInt('${{ steps.summary.outputs.failed }}');

            let summary = `## ðŸ§ª Container Test Summary\n\n`;
            summary += `**Results:** ${passed}/${total} recipes passed\n\n`;

            if (failed > 0) {
              summary += `âŒ ${failed} recipe(s) failed testing\n`;
              summary += `Please check the individual test results above for details.\n\n`;
            } else {
              summary += `âœ… All modified containers passed testing!\n\n`;
            }

            summary += `*This comment will be updated as tests complete.*`;

            // Find existing summary comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const summaryComment = comments.data.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Container Test Summary')
            );

            if (summaryComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: summaryComment.id,
                body: summary
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: summary
              });
            }

            // Fail the workflow if any tests failed
            if (failed > 0) {
              core.setFailed(`${failed} out of ${total} container tests failed`);
            }
