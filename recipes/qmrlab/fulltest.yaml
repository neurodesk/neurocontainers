# qMRLab container test suite
# Tests for qMRLab v2.4.2 - Quantitative MRI analysis toolbox
#
# qMRLab is an open-source software for quantitative MR image analysis
# providing data fitting, plotting, simulation and protocol optimization
# for various quantitative MRI models.
#
# Test data: ds000001/sub-01 (OpenNeuro Balloon Analog Risk-taking Task)
#   - T1w: 160x192x192, 1x1.33x1.33mm (3D structural)
#   - inplaneT2: Lower resolution T2-weighted scan
#
# Note: qMRLab is an Octave/MATLAB toolbox. Most qMRI models require
# specific acquisition protocols (multiple TIs, TEs, flip angles, etc.)
# that are not present in standard BIDS datasets. Tests focus on:
#   - Environment verification
#   - Model instantiation and configuration
#   - Simulations and synthetic data generation
#   - Basic data I/O operations

name: qmrlab
version: 2.4.2
container: qmrlab_2.4.2_20240828.simg

required_files:
  - dataset: ds000001
    files:
      - sub-01/anat/sub-01_T1w.nii.gz
      - sub-01/anat/sub-01_inplaneT2.nii.gz

test_data:
  t1w: ds000001/sub-01/anat/sub-01_T1w.nii.gz
  t2: ds000001/sub-01/anat/sub-01_inplaneT2.nii.gz
  output_dir: test_output

# Octave initialization command (used as prefix for all qMRLab commands)
octave_init: |
  addpath(genpath('/qMRLab-2.4.2'));
  pkg load struct;
  pkg load io;
  pkg load statistics;
  pkg load optim;
  pkg load image;
  warning('off', 'all');

setup:
  script: |
    #!/usr/bin/env bash
    set -e
    mkdir -p test_output

tests:
  # ==========================================================================
  # ENVIRONMENT VERIFICATION
  # ==========================================================================
  - name: Octave version check
    description: Verify GNU Octave is installed and accessible
    command: octave --no-gui --version 2>/dev/null | head -1
    expected_output_contains: "GNU Octave"
    expected_exit_code: 0

  - name: Octave packages available
    description: Check that required Octave packages are installed
    command: octave --no-gui --eval "pkg list" 2>&1 | grep -E "(struct|io|statistics|optim|image)"
    expected_exit_code: 0

  - name: qMRLab installation check
    description: Verify qMRLab directory exists and is accessible
    command: ls -la /qMRLab-2.4.2/qMRLab.m
    expected_exit_code: 0

  - name: qMRLab version check
    description: Read qMRLab version file
    command: cat /qMRLab-2.4.2/version.txt
    expected_output_contains: "v2.4.2"
    expected_exit_code: 0

  # ==========================================================================
  # MODEL LISTING AND INSTANTIATION
  # ==========================================================================
  - name: List all available models
    description: Use list_models() to enumerate all qMRLab models
    command: |
      octave --no-gui --eval "
        warning('off', 'all');
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        models = list_models();
        for i = 1:length(models)
          disp(models{i});
        end
      " 2>/dev/null | head -25
    expected_output_contains: "inversion_recovery"
    expected_exit_code: 0

  - name: Instantiate inversion_recovery model
    description: Create inversion_recovery model object for T1 mapping
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = inversion_recovery();
        disp(['Model class: ' class(Model)]);
        disp(['MRI inputs: ' strjoin(Model.MRIinputs, ', ')]);
        disp(['Fit parameters: ' strjoin(Model.xnames, ', ')]);
      " 2>&1 | grep -E "^(Model|MRI|Fit)"
    expected_output_contains: "inversion_recovery"
    expected_exit_code: 0

  - name: Instantiate vfa_t1 model
    description: Create Variable Flip Angle T1 mapping model
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = vfa_t1();
        disp(['Model class: ' class(Model)]);
        disp(['MRI inputs: ' strjoin(Model.MRIinputs, ', ')]);
      " 2>&1 | grep -E "^(Model|MRI)"
    expected_output_contains: "vfa_t1"
    expected_exit_code: 0

  - name: Instantiate mp2rage model
    description: Create MP2RAGE T1 mapping model
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = mp2rage();
        disp(['Model class: ' class(Model)]);
        disp(['MRI inputs: ' strjoin(Model.MRIinputs, ', ')]);
      " 2>&1 | grep -E "^(Model|MRI)"
    expected_output_contains: "mp2rage"
    expected_exit_code: 0

  - name: Instantiate mono_t2 model
    description: Create monoexponential T2 mapping model
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = mono_t2();
        disp(['Model class: ' class(Model)]);
        disp(['MRI inputs: ' strjoin(Model.MRIinputs, ', ')]);
        disp(['Fit parameters: ' strjoin(Model.xnames, ', ')]);
      " 2>&1 | grep -E "^(Model|MRI|Fit)"
    expected_output_contains: "mono_t2"
    expected_exit_code: 0

  - name: Instantiate mwf model
    description: Create Myelin Water Fraction model
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = mwf();
        disp(['Model class: ' class(Model)]);
        disp(['MRI inputs: ' strjoin(Model.MRIinputs, ', ')]);
      " 2>&1 | grep -E "^(Model|MRI)"
    expected_output_contains: "mwf"
    expected_exit_code: 0

  - name: Instantiate mt_ratio model
    description: Create Magnetization Transfer Ratio model
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = mt_ratio();
        disp(['Model class: ' class(Model)]);
        disp(['MRI inputs: ' strjoin(Model.MRIinputs, ', ')]);
      " 2>&1 | grep -E "^(Model|MRI)"
    expected_output_contains: "mt_ratio"
    expected_exit_code: 0

  - name: Instantiate mt_sat model
    description: Create MT saturation model with B1/T1 correction
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = mt_sat();
        disp(['Model class: ' class(Model)]);
        disp(['MRI inputs: ' strjoin(Model.MRIinputs, ', ')]);
      " 2>&1 | grep -E "^(Model|MRI)"
    expected_output_contains: "mt_sat"
    expected_exit_code: 0

  - name: Instantiate dti model
    description: Create Diffusion Tensor Imaging model
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = dti();
        disp(['Model class: ' class(Model)]);
        disp(['MRI inputs: ' strjoin(Model.MRIinputs, ', ')]);
        disp(['Fit parameters: ' strjoin(Model.xnames, ', ')]);
      " 2>&1 | grep -E "^(Model|MRI|Fit)"
    expected_output_contains: "dti"
    expected_exit_code: 0

  - name: Instantiate noddi model
    description: Create NODDI (Neurite Orientation Dispersion and Density Imaging) model
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = noddi();
        disp(['Model class: ' class(Model)]);
        disp(['MRI inputs: ' strjoin(Model.MRIinputs, ', ')]);
      " 2>&1 | grep -E "^(Model|MRI)"
    expected_output_contains: "noddi"
    expected_exit_code: 0

  - name: Instantiate charmed model
    description: Create CHARMED diffusion model
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = charmed();
        disp(['Model class: ' class(Model)]);
        disp(['MRI inputs: ' strjoin(Model.MRIinputs, ', ')]);
      " 2>&1 | grep -E "^(Model|MRI)"
    expected_output_contains: "charmed"
    expected_exit_code: 0

  - name: Instantiate b1_afi model
    description: Create Actual Flip-angle Imaging B1 mapping model
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = b1_afi();
        disp(['Model class: ' class(Model)]);
        disp(['MRI inputs: ' strjoin(Model.MRIinputs, ', ')]);
      " 2>&1 | grep -E "^(Model|MRI)"
    expected_output_contains: "b1_afi"
    expected_exit_code: 0

  - name: Instantiate b1_dam model
    description: Create Double Angle Method B1 mapping model
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = b1_dam();
        disp(['Model class: ' class(Model)]);
        disp(['MRI inputs: ' strjoin(Model.MRIinputs, ', ')]);
      " 2>&1 | grep -E "^(Model|MRI)"
    expected_output_contains: "b1_dam"
    expected_exit_code: 0

  - name: Instantiate qmt_spgr model
    description: Create qMT SPGR model for quantitative magnetization transfer
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = qmt_spgr();
        disp(['Model class: ' class(Model)]);
        disp(['MRI inputs: ' strjoin(Model.MRIinputs, ', ')]);
      " 2>&1 | grep -E "^(Model|MRI)"
    expected_output_contains: "qmt_spgr"
    expected_exit_code: 0

  # ==========================================================================
  # PROTOCOL CONFIGURATION
  # ==========================================================================
  - name: Configure inversion_recovery protocol
    description: Set up TI values for inversion recovery experiment
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = inversion_recovery();
        Model.Prot.IRData.Mat = [50; 100; 200; 400; 800; 1600; 3200]';
        disp('Protocol TI values (ms):');
        disp(Model.Prot.IRData.Mat');
      " 2>&1 | grep -E "^(Protocol|50|100)"
    expected_output_contains: "Protocol"
    expected_exit_code: 0

  - name: Configure mono_t2 protocol
    description: Set up TE values for multi-echo T2 mapping
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = mono_t2();
        Model.Prot.SEdata.Mat = [10:10:320]';
        disp(['Number of echoes: ' num2str(length(Model.Prot.SEdata.Mat))]);
        disp(['First TE: ' num2str(Model.Prot.SEdata.Mat(1)) ' ms']);
        disp(['Last TE: ' num2str(Model.Prot.SEdata.Mat(end)) ' ms']);
      " 2>&1 | grep -E "^(Number|First|Last)"
    expected_output_contains: "Number of echoes"
    expected_exit_code: 0

  - name: Configure vfa_t1 protocol
    description: Set up flip angles for Variable Flip Angle T1 mapping
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = vfa_t1();
        Model.Prot.VFAData.Mat = [3 15; 3 15]';
        disp('VFA Protocol configured');
        disp(['Flip angles: ' num2str(Model.Prot.VFAData.Mat(:,1)')]);
      " 2>&1 | grep -E "^(VFA|Flip)"
    expected_output_contains: "VFA Protocol"
    expected_exit_code: 0

  # ==========================================================================
  # SIGNAL EQUATION TESTS
  # ==========================================================================
  - name: Test inversion_recovery equation
    description: Compute IR signal for known T1 value
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = inversion_recovery();
        Model.Prot.IRData.Mat = [100; 500; 1000; 2000]';
        x.T1 = 1000;
        x.rb = -2000;
        x.ra = 1000;
        Smodel = Model.equation(x);
        disp('IR Signal equation test:');
        disp(['Signal at TI=100ms: ' num2str(Smodel(1), '%.2f')]);
        disp(['Signal at TI=1000ms: ' num2str(Smodel(3), '%.2f')]);
      " 2>&1 | grep -E "^(IR Signal|Signal)"
    expected_output_contains: "IR Signal equation test"
    expected_exit_code: 0

  - name: Test mono_t2 equation
    description: Compute T2 decay signal for known T2 value
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = mono_t2();
        Model.Prot.SEdata.Mat = [20; 40; 60; 80; 100]';
        x.T2 = 80;
        x.M0 = 1000;
        Smodel = Model.equation(x);
        disp('T2 decay equation test:');
        disp(['Signal at TE=20ms: ' num2str(Smodel(1), '%.2f')]);
        disp(['Signal at TE=80ms (T2): ' num2str(Smodel(4), '%.2f')]);
        disp(['Expected ratio (e^-1): ' num2str(exp(-1), '%.4f')]);
      " 2>&1 | grep -E "^(T2 decay|Signal|Expected)"
    expected_output_contains: "T2 decay equation test"
    expected_exit_code: 0

  # ==========================================================================
  # SIMULATION TESTS
  # ==========================================================================
  - name: Simulate single voxel IR curve
    description: Simulate inversion recovery curve with noise and fit
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = inversion_recovery();
        Model.Prot.IRData.Mat = [50; 100; 400; 1100; 2500]';
        x.T1 = 900;
        x.rb = -1800;
        x.ra = 1000;
        Opt.SNR = 100;
        Opt.T1 = 900;
        Opt.M0 = 1000;
        Opt.TR = 5000;
        Opt.FAinv = 180;
        Opt.FAexcite = 90;
        FitResult = Model.Sim_Single_Voxel_Curve(x, Opt, 0);
        disp('Single voxel simulation results:');
        disp(['True T1: 900 ms']);
        disp(['Fitted T1: ' num2str(FitResult.T1, '%.1f') ' ms']);
        error_pct = abs(FitResult.T1 - 900) / 900 * 100;
        disp(['Error: ' num2str(error_pct, '%.1f') ' %%']);
      " 2>&1 | grep -E "^(Single|True|Fitted|Error)"
    expected_output_contains: "Single voxel simulation"
    expected_exit_code: 0

  - name: Simulate single voxel T2 curve
    description: Simulate mono-exponential T2 decay with noise and fit
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = mono_t2();
        Model.Prot.SEdata.Mat = [12:12:120]';
        x.T2 = 80;
        x.M0 = 1000;
        Opt.SNR = 100;
        FitResult = Model.Sim_Single_Voxel_Curve(x, Opt, 0);
        disp('T2 single voxel simulation:');
        disp(['True T2: 80 ms']);
        disp(['Fitted T2: ' num2str(FitResult.T2, '%.1f') ' ms']);
      " 2>&1 | grep -E "^(T2 single|True|Fitted)"
    expected_output_contains: "T2 single voxel simulation"
    expected_exit_code: 0

  - name: Simulate VFA T1 curve
    description: Simulate Variable Flip Angle T1 mapping
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = vfa_t1();
        x.T1 = 1200;
        x.M0 = 1000;
        Opt.SNR = 100;
        FitResult = Model.Sim_Single_Voxel_Curve(x, Opt, 0);
        disp('VFA T1 simulation:');
        disp(['True T1: 1200 ms']);
        disp(['Fitted T1: ' num2str(FitResult.T1, '%.1f') ' ms']);
      " 2>&1 | grep -E "^(VFA|True|Fitted)"
    expected_output_contains: "VFA T1 simulation"
    expected_exit_code: 0

  # ==========================================================================
  # DATA I/O TESTS
  # ==========================================================================
  - name: Load NIfTI data
    description: Test loading NIfTI file using qMRLab's load_nii_data
    command: |
      NIIFILE=$(echo "${t1w}" | sed 's/\.gz$//')
      if [ ! -f "$NIIFILE" ]; then gunzip -k "${t1w}" 2>/dev/null || true; fi
      octave --no-gui --eval "
        warning('off', 'all');
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        niifile = '${t1w}';
        niifile = strrep(niifile, '.nii.gz', '.nii');
        data = load_nii_data(niifile);
        disp('NIfTI loading test:');
        disp(['Data size: ' num2str(size(data))]);
        disp(['Data type: ' class(data)]);
        disp(['Min value: ' num2str(min(data(:)))]);
        disp(['Max value: ' num2str(max(data(:)))]);
      " 2>/dev/null
    expected_output_contains: "NIfTI loading test"
    expected_exit_code: 0

  - name: Load NIfTI header
    description: Test reading NIfTI header information
    command: |
      NIIFILE=$(echo "${t1w}" | sed 's/\.gz$//')
      if [ ! -f "$NIIFILE" ]; then gunzip -k "${t1w}" 2>/dev/null || true; fi
      octave --no-gui --eval "
        warning('off', 'all');
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        niifile = '${t1w}';
        niifile = strrep(niifile, '.nii.gz', '.nii');
        nii = load_nii(niifile);
        disp('NIfTI header test:');
        disp(['Dimensions: ' num2str(nii.hdr.dime.dim(2:4))]);
        disp(['Voxel size: ' num2str(nii.hdr.dime.pixdim(2:4))]);
      " 2>/dev/null
    expected_output_contains: "NIfTI header test"
    expected_exit_code: 0

  # ==========================================================================
  # MT RATIO CALCULATION (uses simple ratio, compatible with any data)
  # ==========================================================================
  - name: MT ratio calculation test
    description: Test MT ratio formula with synthetic data
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = mt_ratio();
        % Create synthetic data
        data.MToff = ones(10,10,10) * 1000;
        data.MTon = ones(10,10,10) * 700;
        FitResults = Model.fit(data);
        disp('MT Ratio calculation test:');
        disp(['Expected MTR: 30%%']);
        disp(['Calculated MTR: ' num2str(FitResults.MTR(5,5,5)) '%%']);
      " 2>&1 | grep -E "^(MT Ratio|Expected|Calculated)"
    expected_output_contains: "MT Ratio calculation test"
    expected_exit_code: 0

  # ==========================================================================
  # DTI MODEL TESTS
  # ==========================================================================
  - name: DTI model configuration
    description: Configure DTI protocol with gradient directions
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = dti();
        disp('DTI Model Configuration:');
        disp(['Protocol fields: ' strjoin(fieldnames(Model.Prot), ', ')]);
        disp(['Output parameters: ' strjoin(Model.xnames, ', ')]);
        disp(['Voxelwise fitting: ' num2str(Model.voxelwise)]);
      " 2>&1 | grep -E "^(DTI|Protocol|Output|Voxelwise)"
    expected_output_contains: "DTI Model Configuration"
    expected_exit_code: 0

  # ==========================================================================
  # PARAMETER BOUNDS AND OPTIONS
  # ==========================================================================
  - name: Check IR parameter bounds
    description: Verify inversion recovery fitting parameter bounds
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = inversion_recovery();
        disp('IR Parameter Bounds:');
        disp(['Parameters: ' strjoin(Model.xnames, ', ')]);
        disp(['Lower bounds: ' num2str(Model.lb)]);
        disp(['Upper bounds: ' num2str(Model.ub)]);
        disp(['Starting point: ' num2str(Model.st)]);
      " 2>&1 | grep -E "^(IR|Parameters|Lower|Upper|Starting)"
    expected_output_contains: "IR Parameter Bounds"
    expected_exit_code: 0

  - name: Check T2 parameter bounds
    description: Verify mono_t2 fitting parameter bounds
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = mono_t2();
        disp('T2 Parameter Bounds:');
        disp(['Parameters: ' strjoin(Model.xnames, ', ')]);
        disp(['Lower bounds: ' num2str(Model.lb)]);
        disp(['Upper bounds: ' num2str(Model.ub)]);
      " 2>&1 | grep -E "^(T2|Parameters|Lower|Upper)"
    expected_output_contains: "T2 Parameter Bounds"
    expected_exit_code: 0

  # ==========================================================================
  # MODEL OPTIONS AND BUTTONS
  # ==========================================================================
  - name: Check IR model options
    description: Verify inversion recovery model options
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = inversion_recovery();
        disp('IR Model Options:');
        opts = fieldnames(Model.options);
        for i = 1:length(opts)
          val = Model.options.(opts{i});
          if ischar(val)
            disp([opts{i} ': ' val]);
          end
        end
      " 2>&1 | grep -E "^(IR Model|method|fitModel)"
    expected_output_contains: "IR Model Options"
    expected_exit_code: 0

  - name: Check T2 model options
    description: Verify mono_t2 model options including offset fitting
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = mono_t2();
        disp('T2 Model Options:');
        disp(['Fit type options available']);
        disp(['Drop first echo option available']);
        disp(['Offset term option available']);
      " 2>&1 | grep -E "^(T2 Model|Fit|Drop|Offset)"
    expected_output_contains: "T2 Model Options"
    expected_exit_code: 0

  # ==========================================================================
  # EXTERNAL TOOLBOXES
  # ==========================================================================
  - name: Check NODDI toolbox
    description: Verify NODDI external toolbox is available
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        warning('off', 'all');
        if exist('SynthMeasWatsonSHCylNeworienFixed', 'file')
          disp('NODDI toolbox: Available');
        else
          disp('NODDI toolbox: Not found');
        end
      " 2>&1 | grep "NODDI toolbox"
    expected_output_contains: "NODDI toolbox"
    expected_exit_code: 0

  - name: Check NIfTI toolbox
    description: Verify NIfTI I/O toolbox is available
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        warning('off', 'all');
        if exist('load_nii', 'file')
          disp('NIfTI toolbox: Available');
        else
          disp('NIfTI toolbox: Not found');
        end
      " 2>&1 | grep "NIfTI toolbox"
    expected_output_contains: "NIfTI toolbox: Available"
    expected_exit_code: 0

  # ==========================================================================
  # SAVE RESULTS TEST
  # ==========================================================================
  - name: Save fit results to MAT file
    description: Test saving fit results in MATLAB format
    command: |
      octave --no-gui --eval "
        warning('off', 'all');
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        % Create mock fit results
        FitResults.T1 = rand(10,10,10) * 1000 + 500;
        FitResults.M0 = rand(10,10,10) * 2000;
        % Save to output directory
        outfile = '${output_dir}/qmrlab_test_results.mat';
        save(outfile, 'FitResults');
        disp('MAT file save test: SUCCESS');
        disp(['Output file: ' outfile]);
      " 2>/dev/null
    validate:
      - output_exists: ${output_dir}/qmrlab_test_results.mat
    expected_exit_code: 0

  - name: Save results to NIfTI
    description: Test saving NIfTI file using save_nii
    command: |
      octave --no-gui --eval "
        warning('off', 'all');
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        % Create a simple NIfTI structure and save it
        nii = make_nii(rand(64,64,32) * 1500 + 500, [2 2 2]);
        outfile = '${output_dir}/qmrlab_test_T1map.nii';
        save_nii(nii, outfile);
        disp('NIfTI save test completed');
        disp(['Output file: ' outfile]);
      " 2>/dev/null
    validate:
      - output_exists: ${output_dir}/qmrlab_test_T1map.nii
    expected_exit_code: 0

  # ==========================================================================
  # BATCH PROCESSING EXAMPLE
  # ==========================================================================
  - name: Generate batch script template
    description: Test qMRgenBatch to create processing script
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = inversion_recovery();
        disp('Batch generation test:');
        disp(['Model: ' class(Model)]);
        disp(['Required inputs: ' strjoin(Model.MRIinputs, ', ')]);
        disp(['Protocol format: ' Model.Prot.IRData.Format{1}]);
      " 2>&1 | grep -E "^(Batch|Model:|Required|Protocol)"
    expected_output_contains: "Batch generation test"
    expected_exit_code: 0

  # ==========================================================================
  # COMPLEX SIMULATION: SENSITIVITY ANALYSIS
  # ==========================================================================
  - name: IR sensitivity analysis setup
    description: Configure sensitivity analysis for inversion recovery
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = inversion_recovery();
        disp('Sensitivity Analysis Setup:');
        disp(['Parameter names: ' strjoin(Model.xnames, ', ')]);
        disp(['Starting point: ' num2str(Model.st)]);
        disp(['Lower bounds: ' num2str(Model.lb)]);
        disp(['Upper bounds: ' num2str(Model.ub)]);
        disp('Ready for sensitivity analysis');
      " 2>&1 | grep -E "^(Sensitivity|Parameter|Starting|Lower|Upper|Ready)"
    expected_output_contains: "Sensitivity Analysis Setup"
    expected_exit_code: 0

  # ==========================================================================
  # QUANTITATIVE MT MODELS
  # ==========================================================================
  - name: qMT SPGR model check
    description: Verify qMT SPGR model configuration
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = qmt_spgr();
        disp('qMT SPGR Model:');
        disp(['MRI inputs: ' strjoin(Model.MRIinputs, ', ')]);
        disp(['Fit parameters: ' strjoin(Model.xnames, ', ')]);
        disp(['Voxelwise: ' num2str(Model.voxelwise)]);
      " 2>&1 | grep -E "^(qMT|MRI|Fit|Voxelwise)"
    expected_output_contains: "qMT SPGR Model"
    expected_exit_code: 0

  - name: qMT bSSFP model check
    description: Verify qMT bSSFP model configuration
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = qmt_bssfp();
        disp('qMT bSSFP Model:');
        disp(['MRI inputs: ' strjoin(Model.MRIinputs, ', ')]);
        disp(['Model type: ' class(Model)]);
      " 2>&1 | grep -E "^(qMT bSSFP|MRI|Model type)"
    expected_output_contains: "qMT bSSFP Model"
    expected_exit_code: 0

  # ==========================================================================
  # FIELD MAP MODELS
  # ==========================================================================
  - name: B0 DEM model check
    description: Verify B0 dual-echo method model
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = b0_dem();
        disp('B0 Dual Echo Model:');
        disp(['MRI inputs: ' strjoin(Model.MRIinputs, ', ')]);
        disp(['Voxelwise: ' num2str(Model.voxelwise)]);
      " 2>&1 | grep -E "^(B0|MRI|Voxelwise)"
    expected_output_contains: "B0 Dual Echo Model"
    expected_exit_code: 0

  # ==========================================================================
  # NOISE ESTIMATION
  # ==========================================================================
  - name: Noise level estimation model
    description: Check noise_level model for noise estimation
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = noise_level();
        disp('Noise Level Model:');
        disp(['MRI inputs: ' strjoin(Model.MRIinputs, ', ')]);
        disp(['Model class: ' class(Model)]);
      " 2>&1 | grep -E "^(Noise|MRI|Model class)"
    expected_output_contains: "Noise Level Model"
    expected_exit_code: 0

  # ==========================================================================
  # DENOISING
  # ==========================================================================
  - name: MPPCA denoising model
    description: Check Marchenko-Pastur PCA denoising model
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = denoising_mppca();
        disp('MPPCA Denoising Model:');
        disp(['MRI inputs: ' strjoin(Model.MRIinputs, ', ')]);
        disp(['Model class: ' class(Model)]);
      " 2>&1 | grep -E "^(MPPCA|MRI|Model class)"
    expected_output_contains: "MPPCA Denoising Model"
    expected_exit_code: 0

  # ==========================================================================
  # MTV MODEL (Macromolecular Tissue Volume)
  # ==========================================================================
  - name: MTV model check
    description: Verify Macromolecular Tissue Volume model
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = mtv();
        disp('MTV Model:');
        disp(['MRI inputs: ' strjoin(Model.MRIinputs, ', ')]);
        disp(['Model class: ' class(Model)]);
      " 2>&1 | grep -E "^(MTV|MRI|Model class)"
    expected_output_contains: "MTV Model"
    expected_exit_code: 0

  # ==========================================================================
  # AMICO MODEL (Accelerated Microstructure Imaging)
  # ==========================================================================
  - name: AMICO model check
    description: Verify AMICO model for accelerated microstructure imaging
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        Model = amico();
        disp('AMICO Model:');
        disp(['MRI inputs: ' strjoin(Model.MRIinputs, ', ')]);
        disp(['Model class: ' class(Model)]);
      " 2>&1 | grep -E "^(AMICO|MRI|Model class)"
    expected_output_contains: "AMICO Model"
    expected_exit_code: 0

  # ==========================================================================
  # UTILITY FUNCTIONS
  # ==========================================================================
  - name: Test extractvoxel function
    description: Test voxel extraction utility
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');
        % Create test data structure
        data.IRData = rand(10,10,10,5);
        data.Mask = ones(10,10,10);
        voxel = [5,5,5];
        datavox = extractvoxel(data, voxel);
        disp('Extract voxel test:');
        disp(['Input size: ' num2str(size(data.IRData))]);
        disp(['Output size: ' num2str(size(datavox.IRData))]);
        disp(['Voxel location: ' num2str(voxel)]);
      " 2>&1 | grep -E "^(Extract|Input|Output|Voxel)"
    expected_output_contains: "Extract voxel test"
    expected_exit_code: 0

  - name: Test Header_Parse function
    description: Test NIfTI header parsing utility
    command: |
      NIIFILE=$(echo "${t1w}" | sed 's/\.gz$//')
      if [ ! -f "$NIIFILE" ]; then gunzip -k "${t1w}" 2>/dev/null || true; fi
      octave --no-gui --eval "
        warning('off', 'all');
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        niifile = '${t1w}';
        niifile = strrep(niifile, '.nii.gz', '.nii');
        nii = load_nii(niifile);
        disp('Header parse test:');
        disp(['Data dimensions: ' num2str(size(nii.img))]);
        disp(['Datatype: ' num2str(nii.hdr.dime.datatype)]);
      " 2>/dev/null
    expected_output_contains: "Header parse test"
    expected_exit_code: 0

  # ==========================================================================
  # FINAL INTEGRATION TEST
  # ==========================================================================
  - name: Full IR simulation and fit workflow
    description: Complete inversion recovery simulation, fitting, and validation
    command: |
      octave --no-gui --eval "
        addpath(genpath('/qMRLab-2.4.2'));
        pkg load struct; pkg load io; pkg load statistics; pkg load optim; pkg load image;
        warning('off', 'all');

        % Create model
        Model = inversion_recovery();
        Model.Prot.IRData.Mat = [50; 100; 200; 400; 800; 1600; 3200]';

        % True parameters
        true_T1 = 1000;
        x.T1 = true_T1;
        x.rb = -2000;
        x.ra = 1000;

        % Simulate with SNR=100
        Opt.SNR = 100;
        Opt.T1 = true_T1;
        Opt.M0 = 1000;
        Opt.TR = 5000;
        Opt.FAinv = 180;
        Opt.FAexcite = 90;

        FitResult = Model.Sim_Single_Voxel_Curve(x, Opt, 0);

        % Compute error
        error_pct = abs(FitResult.T1 - true_T1) / true_T1 * 100;

        disp('=== Full IR Workflow Test ===');
        disp(['True T1: ' num2str(true_T1) ' ms']);
        disp(['Fitted T1: ' num2str(FitResult.T1, '%.1f') ' ms']);
        disp(['Error: ' num2str(error_pct, '%.2f') '%%']);

        if error_pct < 10
          disp('TEST STATUS: PASSED (error < 10%%)');
        else
          disp('TEST STATUS: WARNING (error >= 10%%)');
        end
      " 2>&1 | grep -E "^(===|True|Fitted|Error|TEST)"
    expected_output_contains: "Full IR Workflow Test"
    expected_exit_code: 0

cleanup:
  script: |
    #!/usr/bin/env bash
    # Optionally clean up test outputs
    # rm -rf test_output
    echo "Test outputs preserved in test_output/"
    echo "qMRLab test suite completed"
