# halfpipe container test suite
# Tests for ENIGMA HALFpipe v1.2.3 - Reproducible fMRI analysis pipeline
#
# HALFpipe is a user-friendly software that facilitates reproducible analysis
# of fMRI data, including preprocessing, single-subject feature extraction,
# and group analysis. Built on fMRIPrep 20.2.7.
#
# Test data: ds000001/sub-01 (OpenNeuro Balloon Analog Risk-taking Task)
#   - T1w: 160x192x192, 1x1.33x1.33mm (3D structural)
#   - BOLD: 64x64x33x300, 3.125x3.125x4mm, TR=2s (4D functional)

name: halfpipe
version: 1.2.3
container: halfpipe_1.2.3_20250623.simg

required_files:
  - dataset: ds000001
    files:
      - sub-01/anat/sub-01_T1w.nii.gz
      - sub-01/anat/sub-01_inplaneT2.nii.gz
      - sub-01/func/sub-01_task-balloonanalogrisktask_run-01_bold.nii.gz
      - sub-01/func/sub-01_task-balloonanalogrisktask_run-01_events.tsv

test_data:
  t1w: ds000001/sub-01/anat/sub-01_T1w.nii.gz
  t2: ds000001/sub-01/anat/sub-01_inplaneT2.nii.gz
  bold: ds000001/sub-01/func/sub-01_task-balloonanalogrisktask_run-01_bold.nii.gz
  events: ds000001/sub-01/func/sub-01_task-balloonanalogrisktask_run-01_events.tsv
  bids_dir: ds000001
  output_dir: test_output

setup:
  script: |
    #!/usr/bin/env bash
    set -e
    mkdir -p test_output
    mkdir -p test_output/halfpipe_work
    mkdir -p test_output/ants_output
    mkdir -p test_output/nibabel_output
    mkdir -p test_output/nilearn_output

tests:
  # ==========================================================================
  # BASIC FUNCTIONALITY - VERSION AND HELP
  # ==========================================================================
  - name: HALFpipe version check
    description: Verify halfpipe binary runs and reports version
    command: halfpipe --version
    expected_output_contains: "1.2.3"

  - name: HALFpipe help
    description: Display halfpipe help message
    command: halfpipe --help 2>&1 | head -20
    expected_output_contains: "ENIGMA HALFpipe"

  - name: HALFpipe group-level help
    description: Display group-level subcommand help
    command: halfpipe group-level --help 2>&1 | head -20
    expected_output_contains: "group-level"

  # ==========================================================================
  # FMRIPREP FUNCTIONALITY
  # ==========================================================================
  - name: fMRIPrep version check
    description: Verify fmriprep binary runs and reports version
    command: fmriprep --version 2>&1
    expected_output_contains: "20.2.7"

  - name: fMRIPrep help
    description: Display fmriprep help message
    command: fmriprep --help 2>&1 | head -30
    expected_output_contains: "fMRIPrep"

  # ==========================================================================
  # PYTHON ENVIRONMENT TESTS
  # ==========================================================================
  - name: Python version check
    description: Verify Python version in container
    command: python3 --version
    expected_output_contains: "Python 3"

  - name: Halfpipe module import
    description: Verify halfpipe Python module can be imported
    command: python3 -c "import halfpipe; print('halfpipe version:', halfpipe.__version__)"
    expected_output_contains: "halfpipe version: 1.2.3"

  - name: Nipype module import
    description: Verify nipype module can be imported
    command: python3 -c "import nipype; print('nipype version:', nipype.__version__)"
    expected_output_contains: "nipype version:"

  - name: Nibabel module import
    description: Verify nibabel module can be imported
    command: python3 -c "import nibabel; print('nibabel version:', nibabel.__version__)"
    expected_output_contains: "nibabel version:"

  - name: Nilearn module import
    description: Verify nilearn module can be imported
    command: python3 -c "import nilearn; print('nilearn version:', nilearn.__version__)"
    expected_output_contains: "nilearn version:"

  # ==========================================================================
  # NIBABEL IMAGE OPERATIONS
  # ==========================================================================
  - name: Nibabel load T1w
    description: Load T1w image with nibabel and print header info
    command: |
      python3 -c "
      import nibabel as nib
      img = nib.load('${t1w}')
      print('Shape:', img.shape)
      print('Voxel sizes:', img.header.get_zooms())
      print('Data type:', img.get_data_dtype())
      "
    expected_output_contains: "Shape: (160, 192, 192)"

  - name: Nibabel load BOLD
    description: Load BOLD image with nibabel and print header info
    command: |
      python3 -c "
      import nibabel as nib
      img = nib.load('${bold}')
      print('Shape:', img.shape)
      print('Voxel sizes:', img.header.get_zooms())
      print('TR:', img.header.get_zooms()[3])
      "
    expected_output_contains: "Shape: (64, 64, 33, 300)"

  - name: Nibabel save image
    description: Create and save a modified image using nibabel
    command: |
      python3 -c "
      import nibabel as nib
      import numpy as np
      img = nib.load('${t1w}')
      data = img.get_fdata()
      # Normalize to 0-1 range
      data_norm = (data - data.min()) / (data.max() - data.min())
      new_img = nib.Nifti1Image(data_norm.astype(np.float32), img.affine, img.header)
      nib.save(new_img, 'test_output/nibabel_output/t1w_normalized.nii.gz')
      print('Saved normalized image')
      "
    validate:
      - output_exists: ${output_dir}/nibabel_output/t1w_normalized.nii.gz

  - name: Nibabel extract mean volume
    description: Extract temporal mean from 4D BOLD using nibabel
    command: |
      python3 -c "
      import nibabel as nib
      import numpy as np
      img = nib.load('${bold}')
      data = img.get_fdata()
      mean_data = np.mean(data, axis=3)
      new_img = nib.Nifti1Image(mean_data.astype(np.float32), img.affine)
      nib.save(new_img, 'test_output/nibabel_output/bold_mean.nii.gz')
      print('Saved mean volume, shape:', mean_data.shape)
      "
    validate:
      - output_exists: ${output_dir}/nibabel_output/bold_mean.nii.gz

  - name: Nibabel extract single volume
    description: Extract first volume from 4D BOLD
    command: |
      python3 -c "
      import nibabel as nib
      img = nib.load('${bold}')
      first_vol = img.slicer[:, :, :, 0]
      nib.save(first_vol, 'test_output/nibabel_output/bold_vol0.nii.gz')
      print('Saved first volume')
      "
    validate:
      - output_exists: ${output_dir}/nibabel_output/bold_vol0.nii.gz

  # ==========================================================================
  # NILEARN OPERATIONS
  # ==========================================================================
  - name: Nilearn compute brain mask
    description: Compute brain mask from BOLD using nilearn
    command: |
      python3 -c "
      from nilearn import masking
      import nibabel as nib
      mask = masking.compute_epi_mask('${bold}')
      nib.save(mask, 'test_output/nilearn_output/bold_mask.nii.gz')
      print('Brain mask shape:', mask.shape)
      print('Non-zero voxels:', mask.get_fdata().sum())
      "
    validate:
      - output_exists: ${output_dir}/nilearn_output/bold_mask.nii.gz

  - name: Nilearn apply mask
    description: Apply brain mask to BOLD data
    command: |
      python3 -c "
      from nilearn import masking
      import nibabel as nib
      mask = nib.load('test_output/nilearn_output/bold_mask.nii.gz')
      masked_data = masking.apply_mask('${bold}', mask)
      print('Masked data shape (timepoints x voxels):', masked_data.shape)
      "
    depends_on: Nilearn compute brain mask
    expected_output_contains: "Masked data shape"
    expected_exit_code: 0

  - name: Nilearn signal cleaning
    description: Clean fMRI signal (detrend, standardize)
    command: |
      python3 -c "
      from nilearn import signal, masking
      import nibabel as nib
      import numpy as np

      mask = nib.load('test_output/nilearn_output/bold_mask.nii.gz')
      masked_data = masking.apply_mask('${bold}', mask)

      # Clean the signal
      cleaned_data = signal.clean(
          masked_data,
          detrend=True,
          standardize=True,
          t_r=2.0
      )
      print('Cleaned data shape:', cleaned_data.shape)
      print('Cleaned data mean:', np.mean(cleaned_data))
      print('Cleaned data std:', np.std(cleaned_data))
      "
    depends_on: Nilearn compute brain mask
    expected_output_contains: "Cleaned data shape"

  - name: Nilearn bandpass filtering
    description: Apply bandpass filter to fMRI data
    command: |
      python3 -c "
      from nilearn import signal, masking
      import nibabel as nib

      mask = nib.load('test_output/nilearn_output/bold_mask.nii.gz')
      masked_data = masking.apply_mask('${bold}', mask)

      # Bandpass filter (0.01-0.1 Hz)
      filtered_data = signal.clean(
          masked_data,
          detrend=True,
          standardize=False,
          low_pass=0.1,
          high_pass=0.01,
          t_r=2.0
      )
      print('Filtered data shape:', filtered_data.shape)
      "
    depends_on: Nilearn compute brain mask
    expected_output_contains: "Filtered data shape"

  - name: Nilearn smoothing
    description: Smooth BOLD image using nilearn
    command: |
      python3 -c "
      from nilearn import image
      import nibabel as nib

      smoothed = image.smooth_img('${bold}', fwhm=6)
      nib.save(smoothed, 'test_output/nilearn_output/bold_smoothed.nii.gz')
      print('Smoothed image saved, shape:', smoothed.shape)
      "
    validate:
      - output_exists: ${output_dir}/nilearn_output/bold_smoothed.nii.gz

  - name: Nilearn resample image
    description: Resample T1w to different resolution
    command: |
      python3 -c "
      from nilearn import image
      import nibabel as nib

      # Resample to 2mm isotropic
      resampled = image.resample_img(
          '${t1w}',
          target_affine=None,
          target_shape=None,
          interpolation='continuous'
      )
      nib.save(resampled, 'test_output/nilearn_output/t1w_resampled.nii.gz')
      print('Resampled image saved')
      "
    validate:
      - output_exists: ${output_dir}/nilearn_output/t1w_resampled.nii.gz

  - name: Nilearn compute mean image
    description: Compute mean across 4D image
    command: |
      python3 -c "
      from nilearn import image
      import nibabel as nib

      mean_img = image.mean_img('${bold}')
      nib.save(mean_img, 'test_output/nilearn_output/bold_mean_nilearn.nii.gz')
      print('Mean image shape:', mean_img.shape)
      "
    validate:
      - output_exists: ${output_dir}/nilearn_output/bold_mean_nilearn.nii.gz

  # ==========================================================================
  # ANTS TOOLS
  # ==========================================================================
  - name: ANTs N4 bias correction
    description: Run N4 bias field correction on T1w
    command: |
      N4BiasFieldCorrection \
        -d 3 \
        -i ${t1w} \
        -o test_output/ants_output/t1w_n4corrected.nii.gz \
        -v 0
    validate:
      - output_exists: ${output_dir}/ants_output/t1w_n4corrected.nii.gz

  - name: ANTs ImageMath operations
    description: Test ANTs ImageMath for basic operations
    command: |
      ImageMath 3 test_output/ants_output/t1w_normalized.nii.gz Normalize ${t1w}
    validate:
      - output_exists: ${output_dir}/ants_output/t1w_normalized.nii.gz

  - name: ANTs create brain mask with Atropos
    description: Create simple threshold mask using ANTs
    command: |
      ThresholdImage 3 ${t1w} test_output/ants_output/t1w_thresh_mask.nii.gz 50 Inf
    validate:
      - output_exists: ${output_dir}/ants_output/t1w_thresh_mask.nii.gz

  - name: ANTs apply transforms info
    description: Check ANTs transform info utility exists
    command: which antsTransformInfo && echo "antsTransformInfo found"
    expected_output_contains: "antsTransformInfo found"

  - name: ANTs registration info
    description: Check ANTs registration utility
    command: antsRegistration --help 2>&1 | head -10
    expected_output_contains: "antsRegistration"

  - name: ANTs motion correction info
    description: Check ANTs motion correction utility
    command: antsMotionCorr --help 2>&1 | head -10
    expected_output_contains: "antsMotionCorr"

  # ==========================================================================
  # C3D TOOLS
  # ==========================================================================
  - name: C3D version check
    description: Check c3d version
    command: c3d -version 2>&1 || echo "c3d available"
    expected_exit_code: 0

  - name: C3D image info
    description: Display image info using c3d
    command: c3d ${t1w} -info
    expected_output_contains: "Image #1"

  - name: C3D resample image
    description: Resample image to isotropic 2mm using c3d
    command: c3d ${t1w} -resample 50% -o test_output/ants_output/t1w_c3d_resample.nii.gz
    validate:
      - output_exists: ${output_dir}/ants_output/t1w_c3d_resample.nii.gz

  - name: C3D threshold
    description: Threshold image using c3d
    command: c3d ${t1w} -threshold 100 inf 1 0 -o test_output/ants_output/t1w_c3d_thresh.nii.gz
    validate:
      - output_exists: ${output_dir}/ants_output/t1w_c3d_thresh.nii.gz

  - name: C3D smoothing
    description: Apply Gaussian smoothing using c3d
    command: c3d ${t1w} -smooth 2mm -o test_output/ants_output/t1w_c3d_smooth.nii.gz
    validate:
      - output_exists: ${output_dir}/ants_output/t1w_c3d_smooth.nii.gz

  - name: C3D affine tool check
    description: Check c3d_affine_tool availability
    command: c3d_affine_tool 2>&1 | head -5
    expected_output_contains: "Affine Transform Tool"

  # ==========================================================================
  # FREESURFER TOOLS (if available)
  # ==========================================================================
  - name: FreeSurfer mri_info
    description: Check FreeSurfer mri_info utility
    command: which mri_info 2>/dev/null && mri_info --help 2>&1 | head -10 || echo "mri_info check completed"
    expected_exit_code: 0

  - name: FreeSurfer environment check
    description: Check FreeSurfer environment variables
    command: echo "FREESURFER_HOME=${FREESURFER_HOME:-/opt/freesurfer}"
    expected_output_contains: "FREESURFER_HOME"

  # ==========================================================================
  # ICA-AROMA
  # ==========================================================================
  - name: ICA-AROMA files check
    description: Verify ICA-AROMA files are present
    command: ls -la /opt/ICA-AROMA/
    expected_output_contains: "ICA_AROMA.py"

  - name: ICA-AROMA help
    description: Check ICA-AROMA help (requires specific environment)
    command: python3 /opt/ICA-AROMA/ICA_AROMA.py --help 2>&1 | head -20 || echo "ICA-AROMA available"
    expected_exit_code: 0

  # ==========================================================================
  # NIPYPE WORKFLOW TESTS
  # ==========================================================================
  - name: Nipype interfaces import
    description: Test nipype interface imports
    command: |
      python3 -c "
      from nipype.interfaces import fsl, ants, freesurfer
      from nipype.interfaces.utility import IdentityInterface
      from nipype.pipeline import Node, Workflow
      print('Nipype interfaces imported successfully')
      "
    expected_output_contains: "Nipype interfaces imported successfully"

  - name: Nipype simple workflow
    description: Create and inspect a simple nipype workflow
    command: |
      python3 -c "
      from nipype.pipeline import Workflow, Node
      from nipype.interfaces.utility import IdentityInterface

      # Create a simple workflow
      wf = Workflow(name='test_workflow', base_dir='test_output/halfpipe_work')

      # Add an input node
      inputnode = Node(
          IdentityInterface(fields=['in_file']),
          name='inputnode'
      )
      inputnode.inputs.in_file = '${t1w}'

      wf.add_nodes([inputnode])
      print('Workflow created:', wf.name)
      print('Nodes:', wf.list_node_names())
      "
    expected_output_contains: "Workflow created: test_workflow"

  # ==========================================================================
  # HALFPIPE SPECIFIC TESTS
  # ==========================================================================
  - name: HALFpipe spec file check
    description: Test halfpipe spec file functionality
    command: |
      python3 -c "
      from halfpipe.model.spec import Spec
      print('Spec class imported successfully')
      "
    expected_output_contains: "Spec class imported successfully"

  - name: HALFpipe BIDS validation
    description: Test BIDS dataset validation with halfpipe
    command: |
      python3 -c "
      from bids import BIDSLayout
      layout = BIDSLayout('${bids_dir}', validate=False)
      print('BIDS subjects:', layout.get_subjects())
      print('BIDS tasks:', layout.get_tasks())
      "
    expected_output_contains: "BIDS subjects:"

  # ==========================================================================
  # BIDS OPERATIONS
  # ==========================================================================
  - name: PyBIDS layout creation
    description: Create BIDS layout and query data
    command: |
      python3 -c "
      from bids import BIDSLayout
      layout = BIDSLayout('${bids_dir}', validate=False)

      # Get all T1w files
      t1w_files = layout.get(suffix='T1w', extension='nii.gz')
      print('Number of T1w files:', len(t1w_files))

      # Get all BOLD files
      bold_files = layout.get(suffix='bold', extension='nii.gz')
      print('Number of BOLD files:', len(bold_files))

      # Get metadata
      if bold_files:
          meta = layout.get_metadata(bold_files[0].path)
          print('BOLD TR:', meta.get('RepetitionTime', 'N/A'))
      "
    expected_output_contains: "Number of T1w files:"

  - name: PyBIDS subject query
    description: Query specific subject data using PyBIDS
    command: |
      python3 -c "
      from bids import BIDSLayout
      layout = BIDSLayout('${bids_dir}', validate=False)

      # Get subject 01 data
      sub01_files = layout.get(subject='01')
      print('Subject 01 files:', len(sub01_files))

      # Get functional runs
      runs = layout.get(subject='01', suffix='bold', return_type='file')
      print('Number of BOLD runs for sub-01:', len(runs))
      "
    expected_output_contains: "Subject 01 files:"

  # ==========================================================================
  # HALFPIPE CONFIGURATION TESTS
  # ==========================================================================
  # ==========================================================================
  # STATISTICAL ANALYSIS TOOLS
  # ==========================================================================
  - name: Scipy stats import
    description: Test scipy statistical functions
    command: |
      python3 -c "
      from scipy import stats
      import numpy as np

      # Test basic stats
      data = np.random.randn(100)
      t_stat, p_val = stats.ttest_1samp(data, 0)
      print('T-test result: t =', round(t_stat, 4), ', p =', round(p_val, 4))
      "
    expected_output_contains: "T-test result:"

  - name: Statsmodels import
    description: Test statsmodels for GLM analysis
    command: |
      python3 -c "
      import statsmodels.api as sm
      import numpy as np

      # Simple regression test
      X = np.random.randn(50, 2)
      X = sm.add_constant(X)
      y = np.random.randn(50)

      model = sm.OLS(y, X)
      results = model.fit()
      print('R-squared:', round(results.rsquared, 4))
      print('Statsmodels OLS working')
      "
    expected_output_contains: "Statsmodels OLS working"

  # ==========================================================================
  # IMAGE QUALITY METRICS
  # ==========================================================================
  - name: Compute temporal SNR
    description: Calculate temporal SNR from BOLD data
    command: |
      python3 -c "
      import nibabel as nib
      import numpy as np

      img = nib.load('${bold}')
      data = img.get_fdata()

      # Calculate tSNR
      mean_vol = np.mean(data, axis=3)
      std_vol = np.std(data, axis=3)

      # Avoid division by zero
      std_vol[std_vol == 0] = np.nan
      tsnr = mean_vol / std_vol

      # Save tSNR map
      tsnr_img = nib.Nifti1Image(tsnr.astype(np.float32), img.affine)
      nib.save(tsnr_img, 'test_output/nilearn_output/bold_tsnr.nii.gz')

      # Report statistics
      valid_tsnr = tsnr[~np.isnan(tsnr) & (tsnr > 0)]
      print('Mean tSNR:', round(np.mean(valid_tsnr), 2))
      print('Median tSNR:', round(np.median(valid_tsnr), 2))
      "
    validate:
      - output_exists: ${output_dir}/nilearn_output/bold_tsnr.nii.gz

  - name: Compute framewise displacement proxy
    description: Compute simple motion metrics from BOLD
    command: |
      python3 -c "
      import nibabel as nib
      import numpy as np

      img = nib.load('${bold}')
      data = img.get_fdata()

      # Simple frame-to-frame difference
      diff = np.diff(data, axis=3)
      fd_proxy = np.mean(np.abs(diff), axis=(0, 1, 2))

      print('Number of timepoints:', data.shape[3])
      print('Mean frame-to-frame change:', round(np.mean(fd_proxy), 4))
      print('Max frame-to-frame change:', round(np.max(fd_proxy), 4))
      "
    expected_output_contains: "Number of timepoints: 300"

  # ==========================================================================
  # CONNECTIVITY ANALYSIS
  # ==========================================================================
  - name: Nilearn connectivity extraction
    description: Extract time series and compute connectivity
    command: |
      python3 -c "
      from nilearn import datasets, maskers, connectome
      import numpy as np
      import nibabel as nib

      # Use a simple spherical ROI approach
      from nilearn.maskers import NiftiSpheresMasker

      # Define simple ROI coordinates (example coordinates)
      coords = [(-24, -52, -9), (24, -52, -9), (0, -52, 18)]

      masker = NiftiSpheresMasker(
          coords,
          radius=6,
          standardize=True,
          t_r=2.0,
          low_pass=0.1,
          high_pass=0.01
      )

      # Extract time series
      time_series = masker.fit_transform('${bold}')
      print('Time series shape:', time_series.shape)

      # Compute correlation
      corr = np.corrcoef(time_series.T)
      print('Connectivity matrix shape:', corr.shape)
      print('Mean correlation:', round(np.mean(corr[np.triu_indices(3, k=1)]), 4))
      "
    expected_output_contains: "Time series shape:"

  # ==========================================================================
  # ATLAS AND PARCELLATION
  # ==========================================================================
  - name: Nilearn fetch atlas
    description: Test atlas fetching capability
    command: |
      python3 -c "
      from nilearn import datasets

      # This just checks the function is available
      # Actual download would require network
      print('Atlas fetching functions available')
      print('Available: fetch_atlas_aal, fetch_atlas_harvard_oxford, etc.')
      "
    expected_output_contains: "Atlas fetching functions available"

  # ==========================================================================
  # GROUP LEVEL ANALYSIS PREPARATION
  # ==========================================================================
  - name: HALFpipe group-level dry run
    description: Test group-level command parsing (no actual execution)
    command: |
      halfpipe group-level \
        --input-directory test_output \
        --output-directory test_output/group_output \
        --help 2>&1 | head -5
    expected_output_contains: "group-level"

  # ==========================================================================
  # FILE FORMAT HANDLING
  # ==========================================================================
  - name: Read BIDS events file
    description: Parse BIDS events TSV file
    command: |
      python3 -c "
      import pandas as pd

      events = pd.read_csv('${events}', sep='\t')
      print('Event columns:', list(events.columns))
      print('Number of events:', len(events))
      print('Event types:', events['trial_type'].unique() if 'trial_type' in events.columns else 'N/A')
      "
    expected_output_contains: "Number of events:"

  - name: Read BIDS participants file
    description: Parse BIDS participants TSV file
    command: |
      python3 -c "
      import pandas as pd
      import os

      participants_file = '${bids_dir}/participants.tsv'
      if os.path.exists(participants_file):
          df = pd.read_csv(participants_file, sep='\t')
          print('Columns:', list(df.columns))
          print('Number of participants:', len(df))
      else:
          print('participants.tsv not found')
      "
    expected_output_contains: "participants"

  # ==========================================================================
  # MEMORY AND RESOURCE HANDLING
  # ==========================================================================
  - name: Check available memory tools
    description: Verify memory monitoring capabilities
    command: |
      python3 -c "
      import psutil

      mem = psutil.virtual_memory()
      print('Total memory (GB):', round(mem.total / (1024**3), 2))
      print('Available memory (GB):', round(mem.available / (1024**3), 2))
      "
    expected_output_contains: "Total memory"
    expected_exit_code: 0

  - name: Check CPU resources
    description: Verify CPU detection
    command: |
      python3 -c "
      import os
      import multiprocessing

      print('CPU count:', multiprocessing.cpu_count())
      print('OMP_NUM_THREADS:', os.environ.get('OMP_NUM_THREADS', 'not set'))
      "
    expected_output_contains: "CPU count:"

  # ==========================================================================
  # REPRODUCIBILITY TESTS
  # ==========================================================================
  - name: Random seed handling
    description: Test reproducible random number generation
    command: |
      python3 -c "
      import numpy as np

      np.random.seed(42)
      arr1 = np.random.randn(5)

      np.random.seed(42)
      arr2 = np.random.randn(5)

      print('Arrays identical:', np.allclose(arr1, arr2))
      print('Reproducibility check passed')
      "
    expected_output_contains: "Reproducibility check passed"

  # ==========================================================================
  # COMPREHENSIVE PIPELINE SIMULATION
  # ==========================================================================
  - name: Simulated preprocessing pipeline
    description: Simulate a minimal preprocessing pipeline
    command: |
      python3 -c "
      import nibabel as nib
      import numpy as np
      from nilearn import image, masking, signal

      print('=== Simulated Preprocessing Pipeline ===')

      # 1. Load data
      print('1. Loading BOLD data...')
      bold_img = nib.load('${bold}')
      print('   Shape:', bold_img.shape)

      # 2. Compute brain mask
      print('2. Computing brain mask...')
      mask_img = masking.compute_epi_mask(bold_img)

      # 3. Apply mask and clean signal
      print('3. Extracting and cleaning signal...')
      masked_data = masking.apply_mask(bold_img, mask_img)
      cleaned_data = signal.clean(
          masked_data,
          detrend=True,
          standardize=True,
          t_r=2.0,
          high_pass=0.01,
          low_pass=0.1
      )
      print('   Cleaned data shape:', cleaned_data.shape)

      # 4. Unmask back to image
      print('4. Reconstructing cleaned image...')
      cleaned_img = masking.unmask(cleaned_data, mask_img)

      # 5. Smooth
      print('5. Applying spatial smoothing...')
      smoothed_img = image.smooth_img(cleaned_img, fwhm=6)

      # 6. Save
      print('6. Saving output...')
      nib.save(smoothed_img, 'test_output/nilearn_output/bold_preprocessed.nii.gz')

      print('=== Pipeline completed successfully ===')
      "
    validate:
      - output_exists: ${output_dir}/nilearn_output/bold_preprocessed.nii.gz

cleanup:
  script: |
    #!/usr/bin/env bash
    # Optionally remove test outputs
    # rm -rf test_output
    echo "Test outputs preserved in test_output/"
