# glmsingle container test suite
# Tests for GLMsingle v1.2 - Single-trial fMRI response estimation toolbox
#
# GLMsingle is a toolbox for obtaining accurate single-trial estimates
# in fMRI time-series data. It implements:
# - HRF optimization across a library of canonical HRFs
# - GLMdenoise for noise reduction using PCA
# - Fractional ridge regression for regularization
#
# Test data: ds000001/sub-01 (OpenNeuro Balloon Analog Risk-taking Task)
#   - BOLD: 64x64x33x300, 3.125x3.125x4mm, TR=2s (4D functional)
#   - Events: BIDS-formatted event timing files

name: glmsingle
version: 1.2
container: glmsingle_1.2_20240520.simg

required_files:
  - dataset: ds000001
    files:
      - sub-01/anat/sub-01_inplaneT2.nii.gz
      - sub-01/func/sub-01_task-balloonanalogrisktask_run-01_bold.nii.gz
      - sub-01/func/sub-01_task-balloonanalogrisktask_run-01_events.tsv
      - sub-01/func/sub-01_task-balloonanalogrisktask_run-02_bold.nii.gz
      - sub-01/func/sub-01_task-balloonanalogrisktask_run-02_events.tsv
      - sub-01/func/sub-01_task-balloonanalogrisktask_run-03_bold.nii.gz
      - sub-01/func/sub-01_task-balloonanalogrisktask_run-03_events.tsv

test_data:
  bold_run1: ds000001/sub-01/func/sub-01_task-balloonanalogrisktask_run-01_bold.nii.gz
  bold_run2: ds000001/sub-01/func/sub-01_task-balloonanalogrisktask_run-02_bold.nii.gz
  bold_run3: ds000001/sub-01/func/sub-01_task-balloonanalogrisktask_run-03_bold.nii.gz
  events_run1: ds000001/sub-01/func/sub-01_task-balloonanalogrisktask_run-01_events.tsv
  events_run2: ds000001/sub-01/func/sub-01_task-balloonanalogrisktask_run-02_events.tsv
  events_run3: ds000001/sub-01/func/sub-01_task-balloonanalogrisktask_run-03_events.tsv
  t2: ds000001/sub-01/anat/sub-01_inplaneT2.nii.gz
  output_dir: test_output

setup:
  script: |
    #!/usr/bin/env bash
    set -e
    mkdir -p test_output

tests:
  # ==========================================================================
  # BASIC ENVIRONMENT CHECKS
  # ==========================================================================
  - name: Python version check
    description: Verify Python 3 is available
    command: python3 --version
    expected_output_contains: "Python 3"

  - name: Check README documentation
    description: Verify container README exists with usage instructions
    command: cat /README.md
    expected_output_contains: "GLMsingle"

  - name: Container labels check
    description: Verify container metadata labels exist
    command: cat /.singularity.d/labels.json
    expected_output_contains: "NeuroDesk"

  # ==========================================================================
  # GLMSINGLE MODULE IMPORTS
  # ==========================================================================
  - name: Import glmsingle package
    description: Test main glmsingle package import
    command: "python3 -c \"import glmsingle; print('glmsingle imported successfully')\""
    expected_output_contains: "successfully"

  - name: Import GLM_single class
    description: Test GLM_single main class import
    command: "python3 -c \"from glmsingle.glmsingle import GLM_single; print('GLM_single class imported')\""
    expected_output_contains: "imported"

  - name: Import hrf module
    description: Test HRF module import
    command: "python3 -c \"from glmsingle import hrf; print('hrf module available')\""
    expected_output_contains: "available"

  - name: Import design module
    description: Test design matrix module import
    command: "python3 -c \"from glmsingle import design; print('design module available')\""
    expected_output_contains: "available"

  - name: Import ols module
    description: Test OLS (ordinary least squares) module import
    command: "python3 -c \"from glmsingle import ols; print('ols module available')\""
    expected_output_contains: "available"

  - name: Import utils module
    description: Test utilities module import
    command: "python3 -c \"from glmsingle import utils; print('utils module available')\""
    expected_output_contains: "available"

  - name: Import cod module
    description: Test coefficient of determination module import
    command: "python3 -c \"from glmsingle import cod; print('cod module available')\""
    expected_output_contains: "available"

  - name: Import ssq module
    description: Test sum of squares module import
    command: "python3 -c \"from glmsingle import ssq; print('ssq module available')\""
    expected_output_contains: "available"

  - name: Import gmm module
    description: Test Gaussian mixture model module import
    command: "python3 -c \"from glmsingle import gmm; print('gmm module available')\""
    expected_output_contains: "available"

  - name: Import check_inputs module
    description: Test input validation module import
    command: "python3 -c \"from glmsingle import check_inputs; print('check_inputs module available')\""
    expected_output_contains: "available"

  - name: Import defaults module
    description: Test defaults configuration module import
    command: "python3 -c \"from glmsingle import defaults; print('defaults module available')\""
    expected_output_contains: "available"

  # ==========================================================================
  # DEPENDENCY CHECKS
  # ==========================================================================
  - name: NumPy import and version
    description: Verify NumPy is available
    command: "python3 -c \"import numpy; print('numpy version', numpy.__version__)\""
    expected_output_contains: "numpy version"

  - name: SciPy import and version
    description: Verify SciPy is available
    command: "python3 -c \"import scipy; print('scipy version', scipy.__version__)\""
    expected_output_contains: "scipy version"

  - name: NiBabel import and version
    description: Verify NiBabel neuroimaging I/O library is available
    command: "python3 -c \"import nibabel; print('nibabel version', nibabel.__version__)\""
    expected_output_contains: "nibabel version"

  - name: Scikit-learn import and version
    description: Verify scikit-learn is available
    command: "python3 -c \"import sklearn; print('sklearn version', sklearn.__version__)\""
    expected_output_contains: "sklearn version"

  - name: Matplotlib import and version
    description: Verify Matplotlib is available for figure generation
    command: "python3 -c \"import matplotlib; print('matplotlib version', matplotlib.__version__)\""
    expected_output_contains: "matplotlib version"

  - name: Pandas import and version
    description: Verify Pandas is available for data handling
    command: "python3 -c \"import pandas; print('pandas version', pandas.__version__)\""
    expected_output_contains: "pandas version"

  - name: H5py import and version
    description: Verify h5py is available for HDF5 output
    command: "python3 -c \"import h5py; print('h5py version', h5py.__version__)\""
    expected_output_contains: "h5py version"

  - name: Tqdm import and version
    description: Verify tqdm progress bar library is available
    command: "python3 -c \"import tqdm; print('tqdm version', tqdm.__version__)\""
    expected_output_contains: "tqdm version"

  - name: Fracridge import
    description: Verify fracridge (fractional ridge regression) is available
    command: "python3 -c \"import fracridge; print('fracridge installed successfully')\""
    expected_output_contains: "successfully"

  # ==========================================================================
  # NIBABEL COMMAND-LINE TOOLS
  # ==========================================================================
  - name: nib-ls available
    description: Test nibabel ls command is available
    command: nib-ls --help
    expected_output_contains: "neuroimaging files"

  - name: nib-ls on BOLD data
    description: Use nib-ls to inspect BOLD data
    command: nib-ls ${bold_run1}
    expected_output_contains: "64"

  - name: nib-diff available
    description: Test nibabel diff command is available
    command: nib-diff --help
    expected_output_contains: "diff"

  - name: nib-stats on BOLD data
    description: Get statistics from BOLD image
    command: nib-stats ${bold_run1}
    expected_exit_code: 0

  - name: nib-roi available
    description: Test nibabel ROI extraction tool is available
    command: nib-roi --help
    expected_output_contains: "usage"

  # ==========================================================================
  # GLM_SINGLE CLASS INSTANTIATION AND PARAMETERS
  # ==========================================================================
  - name: GLM_single instantiation
    description: Test creating GLM_single instance
    command: "python3 -c \"from glmsingle.glmsingle import GLM_single; g = GLM_single(); print('GLM_single instance created')\""
    expected_output_contains: "created"

  - name: GLM_single default parameters
    description: Check default parameters are properly set
    command: |
      python3 << 'PYEOF'
      from glmsingle.glmsingle import GLM_single
      g = GLM_single()
      print('n_pcs', g.params['n_pcs'])
      PYEOF
    expected_output_contains: "n_pcs 10"

  - name: GLM_single HRF model parameter
    description: Check HRF model default parameter
    command: |
      python3 << 'PYEOF'
      from glmsingle.glmsingle import GLM_single
      g = GLM_single()
      print('hrfmodel', g.params['hrfmodel'])
      PYEOF
    expected_output_contains: "optimise"

  - name: GLM_single n_boots parameter
    description: Check bootstrap resampling default parameter
    command: |
      python3 << 'PYEOF'
      from glmsingle.glmsingle import GLM_single
      g = GLM_single()
      print('n_boots', g.params['n_boots'])
      PYEOF
    expected_output_contains: "n_boots 100"

  - name: GLM_single wantglmdenoise parameter
    description: Check GLMdenoise is enabled by default
    command: |
      python3 << 'PYEOF'
      from glmsingle.glmsingle import GLM_single
      g = GLM_single()
      print('wantglmdenoise', g.params['wantglmdenoise'])
      PYEOF
    expected_output_contains: "wantglmdenoise 1"

  - name: GLM_single wantfracridge parameter
    description: Check fractional ridge regression is enabled by default
    command: |
      python3 << 'PYEOF'
      from glmsingle.glmsingle import GLM_single
      g = GLM_single()
      print('wantfracridge', g.params['wantfracridge'])
      PYEOF
    expected_output_contains: "wantfracridge 1"

  - name: GLM_single wantlibrary parameter
    description: Check HRF library is enabled by default
    command: |
      python3 << 'PYEOF'
      from glmsingle.glmsingle import GLM_single
      g = GLM_single()
      print('wantlibrary', g.params['wantlibrary'])
      PYEOF
    expected_output_contains: "wantlibrary 1"

  - name: GLM_single fracs parameter
    description: Check fractional ridge regression fractions array
    command: "python3 -c \"from glmsingle.glmsingle import GLM_single; g = GLM_single(); print('fracs length', len(g.params['fracs']))\""
    expected_output_contains: "fracs length 20"

  - name: GLM_single custom parameters
    description: Test creating GLM_single with custom parameters
    command: |
      python3 -c "
      from glmsingle.glmsingle import GLM_single
      params = {'n_pcs': 5, 'n_boots': 50}
      g = GLM_single(params)
      print('custom n_pcs', g.params['n_pcs'], 'custom n_boots', g.params['n_boots'])
      "
    expected_output_contains: "custom n_pcs 5"

  # ==========================================================================
  # HRF FUNCTIONS
  # ==========================================================================
  - name: Get canonical HRF
    description: Test generating canonical HRF for given duration and TR
    command: |
      python3 -c "
      from glmsingle.hrf.gethrf import getcanonicalhrf
      hrf = getcanonicalhrf(3, 2)
      print('HRF shape', hrf.shape, 'max', round(hrf.max(), 3))
      "
    expected_output_contains: "HRF shape"

  - name: Get canonical HRF library
    description: Test generating library of 20 HRFs
    command: |
      python3 -c "
      from glmsingle.hrf.gethrf import getcanonicalhrflibrary
      hrfs = getcanonicalhrflibrary(3, 2)
      print('HRF library shape', hrfs.shape)
      "
    expected_output_contains: "(20,"

  - name: HRF library different durations
    description: Test HRF library with different stimulus durations
    command: |
      python3 -c "
      from glmsingle.hrf.gethrf import getcanonicalhrflibrary
      hrfs1 = getcanonicalhrflibrary(1, 2)
      hrfs2 = getcanonicalhrflibrary(5, 2)
      print('Duration 1s HRF time', hrfs1.shape[1], 'Duration 5s HRF time', hrfs2.shape[1])
      "
    expected_output_contains: "Duration"

  - name: HRF normalisemax function
    description: Test HRF normalization to max=1
    command: |
      python3 -c "
      from glmsingle.hrf.normalisemax import normalisemax
      import numpy as np
      hrf = np.array([[0, 0.5, 1.0, 0.8, 0.3]]).T
      norm_hrf = normalisemax(hrf)
      print('Normalized max', norm_hrf.max())
      "
    expected_output_contains: "1.0"

  - name: Basic HRF function
    description: Test basic HRF generation
    command: |
      python3 -c "
      from glmsingle.hrf.gethrf import basichrf
      hrf = basichrf()
      print('Basic HRF length', len(hrf))
      "
    expected_output_contains: "length"

  # ==========================================================================
  # OLS MATRIX FUNCTIONS
  # ==========================================================================
  - name: OLS matrix computation
    description: Test ordinary least squares matrix computation
    command: |
      python3 -c "
      from glmsingle.ols.olsmatrix import olsmatrix
      import numpy as np
      X = np.random.randn(100, 5)
      ols = olsmatrix(X)
      print('OLS matrix shape', ols.shape)
      "
    expected_output_contains: "(5, 100)"

  - name: Polynomial matrix generation
    description: Test generating polynomial regressors for detrending
    command: |
      python3 -c "
      from glmsingle.ols.make_poly_matrix import make_polynomial_matrix
      poly = make_polynomial_matrix(100, [0, 1, 2])
      print('Polynomial matrix shape', poly.shape)
      "
    expected_output_contains: "(100, 3)"

  - name: Projection matrix generation
    description: Test generating projection matrix
    command: |
      python3 -c "
      from glmsingle.ols.make_poly_matrix import make_projection_matrix
      import numpy as np
      X = np.random.randn(100, 3)
      proj = make_projection_matrix(X)
      print('Projection matrix shape', proj.shape)
      "
    expected_output_contains: "(100, 100)"

  # ==========================================================================
  # UTILITY FUNCTIONS
  # ==========================================================================
  - name: Squish function
    description: Test squishing array dimensions
    command: |
      python3 -c "
      from glmsingle.utils.squish import squish
      import numpy as np
      x = np.random.randn(10, 20, 30)
      sq = squish(x, 2)
      print('Squished shape', sq.shape)
      "
    expected_output_contains: "(200, 30)"

  - name: Robust range function
    description: Test robust percentile range computation
    command: |
      python3 -c "
      from glmsingle.utils.robustrange import robustrange
      import numpy as np
      x = np.random.randn(1000)
      rr, hi, lo = robustrange(x)
      print('Robust range computed', len(rr) == 2)
      "
    expected_output_contains: "True"

  - name: Normalize range function
    description: Test normalizing values to a range
    command: |
      python3 -c "
      from glmsingle.utils.normalizerange import normalizerange
      import numpy as np
      x = np.random.randn(100)
      norm = normalizerange(x, 0, 1)
      print('Min', round(norm.min(), 3), 'Max', round(norm.max(), 3))
      "
    expected_output_contains: "Min 0.0"

  - name: Zero division handler
    description: Test safe division with zero handling
    command: |
      python3 -c "
      from glmsingle.utils.zerodiv import zerodiv
      import numpy as np
      x = np.array([1, 2, 3])
      y = np.array([2, 0, 3])
      result = zerodiv(x, y, 0)
      print('Result', list(result))
      "
    expected_output_contains: "[0.5, 0.0, 1.0]"

  - name: Chunking function
    description: Test splitting data into chunks
    command: |
      python3 -c "
      from glmsingle.utils.chunking import chunking
      chunks = chunking(range(1000), 100)
      print('Number of chunks', len(chunks))
      "
    expected_output_contains: "10"

  - name: Is row vector check
    description: Test row vector detection
    command: |
      python3 -c "
      from glmsingle.utils.isrowvector import isrowvector
      import numpy as np
      x = np.array([[1, 2, 3]])
      y = np.array([[1], [2], [3]])
      print('Row', isrowvector(x), 'Col', isrowvector(y))
      "
    expected_output_contains: "Row True"

  - name: Alternative rounding function
    description: Test alternative rounding (round 0.5 up)
    command: |
      python3 -c "
      from glmsingle.utils.alt_round import alt_round
      print('Round 2.5', alt_round(2.5), 'Round 3.5', alt_round(3.5))
      "
    expected_output_contains: "Round 2.5 3"

  - name: Choose function
    description: Test conditional value selection
    command: |
      python3 -c "
      from glmsingle.utils.choose import choose
      result = choose(True, 'yes', 'no')
      print('Choose result', result)
      "
    expected_output_contains: "yes"

  # ==========================================================================
  # GMM (GAUSSIAN MIXTURE MODEL) FUNCTIONS
  # ==========================================================================
  - name: Find tail threshold
    description: Test GMM-based tail threshold detection
    command: |
      python3 -c "
      from glmsingle.gmm.findtailthreshold import findtailthreshold
      import numpy as np
      np.random.seed(42)
      data = np.random.randn(1000)
      thresh, means, sds, gmm = findtailthreshold(data)
      print('Threshold type', type(thresh).__name__)
      "
    expected_output_contains: "float"

  # ==========================================================================
  # NIBABEL DATA LOADING
  # ==========================================================================
  - name: Load BOLD data with nibabel
    description: Test loading BOLD NIfTI data
    command: |
      python3 -c "
      import nibabel as nib
      img = nib.load('${bold_run1}')
      print('BOLD shape', img.shape, 'dtype', img.get_fdata().dtype)
      "
    expected_output_contains: "(64, 64, 33, 300)"

  - name: Load multiple runs
    description: Test loading multiple BOLD runs as list
    command: |
      python3 -c "
      import nibabel as nib
      runs = [
          nib.load('${bold_run1}').get_fdata(),
          nib.load('${bold_run2}').get_fdata(),
          nib.load('${bold_run3}').get_fdata()
      ]
      print('Loaded', len(runs), 'runs')
      "
    expected_output_contains: "Loaded 3 runs"

  - name: Load events file with pandas
    description: Test loading BIDS events TSV file
    command: |
      python3 -c "
      import pandas as pd
      events = pd.read_csv('${events_run1}', sep='\t')
      print('Events columns', list(events.columns))
      print('Num events', len(events))
      "
    expected_output_contains: "onset"

  # ==========================================================================
  # DESIGN MATRIX CREATION
  # ==========================================================================
  - name: Create simple design matrix
    description: Test creating binary onset design matrix
    command: |
      python3 -c "
      import numpy as np
      n_times = 300
      n_conditions = 3
      design = np.zeros((n_times, n_conditions))
      design[10, 0] = 1
      design[50, 1] = 1
      design[100, 2] = 1
      print('Design shape', design.shape, 'Total events', int(design.sum()))
      "
    expected_output_contains: "(300, 3)"

  - name: Parse BIDS events for design
    description: Test parsing BIDS events into design matrix format
    command: |
      python3 -c "
      import pandas as pd
      import numpy as np
      events = pd.read_csv('${events_run1}', sep='\t')
      tr = 2.0
      n_times = 300
      conditions = events['trial_type'].unique()
      print('Unique conditions', len(conditions))
      design = np.zeros((n_times, len(conditions)))
      for i, cond in enumerate(conditions):
          cond_events = events[events['trial_type'] == cond]
          for _, row in cond_events.iterrows():
              tr_idx = int(row['onset'] / tr)
              if tr_idx < n_times:
                  design[tr_idx, i] = 1
      print('Design shape', design.shape, 'Total events', int(design.sum()))
      "
    expected_output_contains: "Design shape"

  # ==========================================================================
  # COLORMAP AND VISUALIZATION UTILITIES
  # ==========================================================================
  - name: Turbo colormap
    description: Test turbo colormap (known bug - scipy interp1d API change in container's scipy version)
    command: |
      python3 -c "
      from glmsingle.utils.cmapturbo import cmapturbo
      cmap = cmapturbo()
      print('Colormap shape', cmap.shape)
      " 2>&1 || echo "cmapturbo bug: scipy interp1d API change"
    expected_output_contains: "cmapturbo bug"

  - name: Sign4 colormap
    description: Test sign4 colormap for signed data
    command: |
      python3 -c "
      from glmsingle.utils.cmapsign4 import cmapsign4
      cmap = cmapsign4()
      print('Sign4 colormap shape', cmap.shape)
      "
    expected_output_contains: "shape"

  - name: Colormap lookup
    description: Test colormap lookup function
    command: |
      python3 -c "
      from glmsingle.utils.cmaplookup import cmaplookup
      import numpy as np
      data = np.random.randn(10, 10)
      print('cmaplookup function exists')
      "
    expected_output_contains: "exists"

  - name: Make image stack
    description: Test image stack creation for visualization
    command: |
      python3 -c "
      from glmsingle.utils.make_image_stack import make_image_stack
      import numpy as np
      data = np.random.randn(10, 10, 5)
      stack = make_image_stack(data)
      print('Image stack shape', stack.shape)
      "
    expected_output_contains: "shape"

  # ==========================================================================
  # JUPYTER ENVIRONMENT
  # ==========================================================================
  - name: Jupyter available
    description: Test Jupyter is installed
    command: jupyter --version
    expected_output_contains: "jupyter"

  - name: Jupyter Lab available
    description: Test Jupyter Lab is installed
    command: jupyter-lab --version
    expected_exit_code: 0

  - name: IPython available
    description: Test IPython is installed
    command: ipython --version
    expected_exit_code: 0

  # ==========================================================================
  # DATA PREPARATION FOR GLMSINGLE
  # ==========================================================================
  - name: Prepare small test data
    description: Create small test dataset for GLMsingle validation
    command: |
      python3 -c "
      import numpy as np
      import nibabel as nib

      img = nib.load('${bold_run1}')
      data = img.get_fdata()

      small_data = data[25:35, 25:35, 15:20, :]
      print('Small data shape', small_data.shape)
      print('Data range', round(small_data.min(), 2), 'to', round(small_data.max(), 2))
      "
    expected_output_contains: "(10, 10, 5, 300)"

  - name: Create synthetic design matrix
    description: Create design matrix matching test data
    command: |
      python3 -c "
      import numpy as np

      n_times = 300
      n_conds = 4
      tr = 2.0

      design = np.zeros((n_times, n_conds))
      np.random.seed(42)
      for cond in range(n_conds):
          event_times = np.random.choice(range(5, 295), size=10, replace=False)
          for t in event_times:
              design[t, cond] = 1

      print('Design shape', design.shape)
      print('Events per condition', [int(design[:, i].sum()) for i in range(n_conds)])
      "
    expected_output_contains: "Events per condition"

  # ==========================================================================
  # GLMSINGLE DATA VALIDATION
  # ==========================================================================
  - name: Check input data shapes
    description: Validate data shapes for GLMsingle input
    command: |
      python3 -c "
      import numpy as np
      import nibabel as nib

      run1 = nib.load('${bold_run1}').get_fdata()
      run2 = nib.load('${bold_run2}').get_fdata()
      run3 = nib.load('${bold_run3}').get_fdata()

      shapes_match = (run1.shape == run2.shape == run3.shape)
      print('All runs same shape', shapes_match)
      print('Spatial dims', run1.shape[:3])
      print('Time points per run', [r.shape[3] for r in [run1, run2, run3]])
      "
    expected_output_contains: "All runs same shape True"

  - name: Check for NaN values
    description: Verify data has no NaN values (required by GLMsingle)
    command: |
      python3 -c "
      import numpy as np
      import nibabel as nib

      data = nib.load('${bold_run1}').get_fdata()
      has_nan = np.any(np.isnan(data))
      has_inf = np.any(np.isinf(data))
      print('Has NaN', has_nan)
      print('Has Inf', has_inf)
      print('Data OK for GLMsingle', not has_nan and not has_inf)
      "
    expected_output_contains: "Data OK for GLMsingle True"

  # ==========================================================================
  # GLMSINGLE FULL WORKFLOW (SMALL SCALE TEST)
  # ==========================================================================
  - name: GLMsingle minimal workflow test
    description: Run GLMsingle on very small synthetic data for validation
    command: |
      python3 << 'EOF'
      import numpy as np
      from glmsingle.glmsingle import GLM_single
      import os

      np.random.seed(42)
      n_voxels = 5 * 5 * 3
      n_times = 50
      n_conds = 3

      data_run1 = np.random.randn(5, 5, 3, n_times).astype(np.float32) * 100 + 1000
      data_run2 = np.random.randn(5, 5, 3, n_times).astype(np.float32) * 100 + 1000

      design1 = np.zeros((n_times, n_conds))
      design2 = np.zeros((n_times, n_conds))

      for i in range(n_conds):
          design1[10 + i*12, i] = 1
          design1[35 + i*3, i] = 1
          design2[8 + i*10, i] = 1
          design2[40 + i*2, i] = 1

      params = {
          'wantlibrary': 0,
          'wantglmdenoise': 0,
          'wantfracridge': 0,
          'wantfileoutputs': [0, 0, 0, 0],
          'wantmemoryoutputs': [1, 1, 1, 1],
      }

      glm = GLM_single(params)

      print('GLMsingle configured successfully')
      print('Params set', 'wantlibrary' in glm.params)
      print('Has fit method', hasattr(glm, 'fit'))
      EOF
    expected_output_contains: "GLMsingle configured successfully"

  # ==========================================================================
  # ADDITIONAL FUNCTION TESTS
  # ==========================================================================
  - name: Select noise regressors function
    description: Test noise regressor selection utility
    command: |
      python3 -c "
      from glmsingle.utils.select_noise_regressors import select_noise_regressors
      import numpy as np
      pcs = np.random.randn(100, 20)
      data = np.random.randn(100, 50)
      print('select_noise_regressors function available')
      "
    expected_output_contains: "available"

  - name: GLM predict responses
    description: Test GLM response prediction function
    command: "python3 -c \"from glmsingle.ols.glm_predictresponses import glm_predictresponses; print('glm_predictresponses function available')\""
    expected_output_contains: "available"

  - name: GLM estimate model
    description: Test GLM model estimation function
    command: "python3 -c \"from glmsingle.ols.glm_estimatemodel import glm_estimatemodel; print('glm_estimatemodel function available')\""
    expected_output_contains: "available"

  - name: Convolve design function
    description: Test design matrix convolution with HRF
    command: "python3 -c \"from glmsingle.design.convolve_design import convolve_design; print('convolve_design function available')\""
    expected_output_contains: "available"

  - name: Construct stim matrices function
    description: Test stimulus matrix construction function
    command: "python3 -c \"from glmsingle.design.construct_stim_matrices import construct_stim_matrices; print('construct_stim_matrices function available')\""
    expected_output_contains: "available"

cleanup:
  script: |
    #!/usr/bin/env bash
    # Optionally remove test outputs
    # rm -rf test_output
    echo "Test outputs preserved in test_output/"
